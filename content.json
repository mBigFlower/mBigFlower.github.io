{"meta":{"title":"春风十里","subtitle":"Fighting","description":"Just do it","author":"胖小了个花","url":"http://flowerfat.com"},"pages":[{"title":"about","date":"2016-05-20T16:34:50.000Z","updated":"2016-05-20T16:37:31.278Z","comments":true,"path":"about/index.html","permalink":"http://flowerfat.com/about/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null}],"posts":[{"title":"三方链接","slug":"各种链接","date":"2016-05-21T12:51:20.286Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2016/05/21/各种链接/","link":"","permalink":"http://flowerfat.com/2016/05/21/各种链接/","excerpt":"","keywords":null,"text":"文章 今日值得读（技术小黑屋） http://droidyue.com/read/ 开放平台 微博sdk介入 http://www.jikexueyuan.com/course/1337.html 百度地图 http://www.imooc.com/view/238 微信sdk-分享 http://www.imooc.com/view/455 UI控件 WebView http://www.imooc.com/view/268 APP源码 安卓巴士推荐APP源码 http://www.apkbus.com/forum.php?mod=viewthread&amp;tid=242910&amp;extra= 视频 慕课网android板块 http://www.imooc.com/course/list?c=android&amp;page=1 书籍百度网盘打包下载（个人分享）： http://pan.baidu.com/s/1sj86yDZ","raw":null,"content":null,"categories":[],"tags":[{"name":"链接","slug":"链接","permalink":"http://flowerfat.com/tags/链接/"}]},{"title":"List中的Contains","slug":"List中的Contains1110","date":"2015-11-09T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/11/10/List中的Contains1110/","link":"","permalink":"http://flowerfat.com/2015/11/10/List中的Contains1110/","excerpt":"感谢文章是我按照我的bug和debug过程写的，这里感谢这篇文章的帮助：http://www.2cto.com/kf/201506/410713.html 背景最近在弄一个通讯录导入小功能：【A操作】读取通讯录-获得列表-选择你想要的某些联系人-保存到安卓客户端。但是遇到个问题：当你导入成功后，【B操作】想再导入几个联系人的时候。再走一遍上述流程，你会发现，通讯录和你本地有重复的数据 那么问题来了：通讯录是一个列表， 客户端本地也有一个列表。我们需要把通讯录读取后，移除我们本地的数据。展示出来的全是未导入的数据 案例contains 1说到一个List里包含某个*， 会不会想到Contains？最常见的是这样的： public void main1(){ ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;张三&quot;); list.add(&quot;李四&quot;); list.add(&quot;王二麻子&quot;); String aimString1 = &quot;李四&quot;; String aimString2 = &quot;我不是黄蓉&quot;; if(list.contains(aimString1)) { Log.i(&quot;是否包含？&quot;, &quot;包含了-李四&quot;); } Log.i(&quot;是否包含？&quot;, &quot;包含了-我不是黄蓉？&quot;+list.contains(aimString2)); } 打印如下： I/是否包含？﹕ 包含了-李四 I/是否包含？﹕ 包含了-我不是黄蓉？false 可以看到Contains很完美的实现了我们的目标！你以为这样这篇文章就结束了？NoNoNo ~ contains 2如果我们要比对的不是String类型，而是一个下面的自定义类呢？ public class userInfo { private int _id ; private String name ; private String phone ; public userInfo(String name){ this.name = name ; } // getter和setter略去 } 测试代码小改动了下，如下： public void main2() { ArrayList&lt;userInfo&gt; list = new ArrayList&lt;&gt;(); list.add(new userInfo(&quot;张三&quot;)); list.add(new userInfo(&quot;李四&quot;)); list.add(new userInfo(&quot;王二麻子&quot;)); userInfo aimUser1 = new userInfo(&quot;李四&quot;); if (list.contains(aimUser1)) { Log.i(&quot;是否包含？&quot;, &quot;包含了-李四&quot;); } else { Log.i(&quot;是否包含？&quot;, &quot;我擦，居然没包含？不科学啊&quot;); } } 打印如下： I/是否包含？﹕ 我擦，居然没包含？不科学啊 contains 进阶","keywords":null,"text":"感谢文章是我按照我的bug和debug过程写的，这里感谢这篇文章的帮助：http://www.2cto.com/kf/201506/410713.html 背景最近在弄一个通讯录导入小功能：【A操作】读取通讯录-获得列表-选择你想要的某些联系人-保存到安卓客户端。但是遇到个问题：当你导入成功后，【B操作】想再导入几个联系人的时候。再走一遍上述流程，你会发现，通讯录和你本地有重复的数据 那么问题来了：通讯录是一个列表， 客户端本地也有一个列表。我们需要把通讯录读取后，移除我们本地的数据。展示出来的全是未导入的数据 案例contains 1说到一个List里包含某个*， 会不会想到Contains？最常见的是这样的： public void main1(){ ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;张三&quot;); list.add(&quot;李四&quot;); list.add(&quot;王二麻子&quot;); String aimString1 = &quot;李四&quot;; String aimString2 = &quot;我不是黄蓉&quot;; if(list.contains(aimString1)) { Log.i(&quot;是否包含？&quot;, &quot;包含了-李四&quot;); } Log.i(&quot;是否包含？&quot;, &quot;包含了-我不是黄蓉？&quot;+list.contains(aimString2)); } 打印如下： I/是否包含？﹕ 包含了-李四 I/是否包含？﹕ 包含了-我不是黄蓉？false 可以看到Contains很完美的实现了我们的目标！你以为这样这篇文章就结束了？NoNoNo ~ contains 2如果我们要比对的不是String类型，而是一个下面的自定义类呢？ public class userInfo { private int _id ; private String name ; private String phone ; public userInfo(String name){ this.name = name ; } // getter和setter略去 } 测试代码小改动了下，如下： public void main2() { ArrayList&lt;userInfo&gt; list = new ArrayList&lt;&gt;(); list.add(new userInfo(&quot;张三&quot;)); list.add(new userInfo(&quot;李四&quot;)); list.add(new userInfo(&quot;王二麻子&quot;)); userInfo aimUser1 = new userInfo(&quot;李四&quot;); if (list.contains(aimUser1)) { Log.i(&quot;是否包含？&quot;, &quot;包含了-李四&quot;); } else { Log.i(&quot;是否包含？&quot;, &quot;我擦，居然没包含？不科学啊&quot;); } } 打印如下： I/是否包含？﹕ 我擦，居然没包含？不科学啊 contains 进阶 有问题就找嘛，我们按住Ctrl点击contains来看源码： @Override public boolean contains(Object object) { Object[] a = array; int s = size; if (object != null) { for (int i = 0; i &lt; s; i++) { if (object.equals(a[i])) { return true; } } } else { for (int i = 0; i &lt; s; i++) { if (a[i] == null) { return true; } } } return false; } PS:系统有啥叼的嘛， 还不是用for循环挨个对比的 里面用到了 object.equals(a[i]) 其源码是 public boolean equals(Object o) { return this == o; } 其实这里面的Object就是我们上面的自定义类userInfo 这上面的源码居然用 this==o 来对比两个实体？这就是判断两者的地址是否相等嘛。可是我们需要的是两者的内容相等 按照文章开头那里感谢的那篇文章，在我们的实体类中重写equals方法，没啥难的，我们一起来看： public class userInfo { private int _id ; private String name ; private String phone ; public userInfo(String name){ this.name = name ; } // getter和setter略去 @Override public boolean equals(Object o) { if(o instanceof userInfo) { // 类型强转 userInfo _userInfo = (userInfo) o ; // // 仅仅比对name // return this.name.equals(_userInfo.getName()) ; // 比对三个参数 return this.name.equals(_userInfo.getName()) &amp;&amp; this.phone.equals(_userInfo.getPhone()) &amp;&amp; this._id == _userInfo.get_id(); } return super.equals(o); } } 这时候再跑一次code ，崩~ NullPointerException String crash = null ; Log.i(&quot;log&quot;, &quot;result:&quot;+crash.equals(&quot;oh no !&quot;)); equals前面是不能为null的。那怎么办？ 我怎么知道。。。 尽量避免不让其为null呗，或者你加判断试试？顺便说一句，下面的写法比较好： String crash = null ; Log.i(&quot;log&quot;, &quot;result:&quot;+&quot;oh no !&quot;.equals(crash)); 实战一开始就说到是一个导入通讯录的小任务嘛，上面一直是举例子，这下轮到实战了。不过我不想写了。任性一回 。","raw":null,"content":null,"categories":[{"name":"安卓","slug":"安卓","permalink":"http://flowerfat.com/categories/安卓/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://flowerfat.com/tags/基础/"}]},{"title":"nodejs搞服务器","slug":"nodejs搞服务器1103","date":"2015-11-02T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/11/03/nodejs搞服务器1103/","link":"","permalink":"http://flowerfat.com/2015/11/03/nodejs搞服务器1103/","excerpt":"","keywords":null,"text":"服务器Tips 服务器就是一台电脑，你只不过是把之前你电脑上的东西放到“另一台电脑”上，然后它不关机的一直运行 windows系统使用XShell链接到服务器，就可以在windows操作服务器了（感觉像远程协助） NodeJsTips问题答疑Q:node app.js后运行起服务器，但是XShell断开与服务器链接后？又跑不起走了。A:使用守护进程forever $ sudo npm install forever -g #安装 $ forever start app.js #启动 $ forever stop app.js #关闭（若发现失败，可能是路径不对） $ forever start -l forever.log -o out.log -e err.log app.js #输出日志和错误 还有个网友的评论很有用： forever -w app.js -w 参数是自动监控文件变化，文件修改保存了自动重启app.js。非常爽。唯一不爽的是那个 .foreverignore 不起作用，作者一直没有修改。 forever相关知识点我","raw":null,"content":null,"categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://flowerfat.com/categories/Nodejs/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://flowerfat.com/tags/基础/"}]},{"title":"使用TextView显示Html","slug":"天狗菜谱（textview与html）1021","date":"2015-10-20T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/10/21/天狗菜谱（textview与html）1021/","link":"","permalink":"http://flowerfat.com/2015/10/21/天狗菜谱（textview与html）1021/","excerpt":"","keywords":null,"text":"说点啥最近研究天狗菜谱的api，里面有一段关于菜谱的详细做法，是以html的格式返回的。一开始很纠结，message字段里面那么多&lt;&gt;的字符 &lt;h2&gt;菜谱简介&lt;/h2&gt;&lt;hr&gt; &lt;h2&gt;材料 &lt;/h2&gt;&lt;hr&gt; &lt;p&gt;面粉200克，杞枣粉20克，酵母2克，糖20克，盐3克，蛋液20克，牛奶100克，黄油8克&lt;/p&gt; &lt;h2&gt;做法 &lt;/h2&gt;&lt;hr&gt; &lt;p&gt;1. 除黄油外，其他材料混合揉成光滑面团，摊开面团，加入融化的黄油，继续揉面至可拉开坚韧的薄膜，收圆入盆，基础发酵． &lt;/p&gt; &lt;p&gt;2. 基础发酵完成后，排气，取出，分割四等份，滚圆，覆盖，中间发酵15分钟． &lt;/p&gt; &lt;p&gt;3. 取一个面团，擀开，翻面，从上往下紧密卷起，收口处捏紧，用手轻轻搓揉成橄榄形． &lt;/p&gt; &lt;p&gt;4. 间隔排放入铺垫好的烤盘上，入烤箱做最后发酵． &lt;/p&gt; &lt;p&gt;5. 最后发酵完成后，刷蛋液，用刀片划开一道口（可省略） &lt;/p&gt; &lt;p&gt;6. 烤箱180度预热好，中层，15分钟（上色均匀后盖锡纸）&lt;/p&gt; 我怎么显示？还要手动把他们去掉？ 后来索性换个思路，直接显示html格式的！ Do其实Android提供了html相关的方法，很简单。在网上搜到了一篇文章，方法如下： TextView textView = (TextView)findViewById(R.id.details_text); textView.setMovementMethod(ScrollingMovementMethod.getInstance());//让TextView可滚动 textView.setText(Html.fromHtml(htmlString)); 其中，htmlString就是我们收到的html格式的message内容，结果直接上图： 是不是感觉还不错？至少省的我们自己去排版了（至于材料里面的酵母为什么自动换行了。额，这个以后再说） 代码最近无聊便再玩聚合里的api，里面就包含天狗的挺多内容相关工程在我的github上：https://github.com/mBigFlower/APIFamily","raw":null,"content":null,"categories":[{"name":"安卓","slug":"安卓","permalink":"http://flowerfat.com/categories/安卓/"}],"tags":[{"name":"控件","slug":"控件","permalink":"http://flowerfat.com/tags/控件/"}]},{"title":"nodejs入门（三）心得","slug":"nodejs入门三1021","date":"2015-10-20T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/10/21/nodejs入门三1021/","link":"","permalink":"http://flowerfat.com/2015/10/21/nodejs入门三1021/","excerpt":"","keywords":null,"text":"说点啥之前是写安卓的，最初接触nodejs的目的，就是为了自己能一个人做一个应用。前面两篇文章，入门一二只是对nodejs的api进行了下分析。其实我后来还是按照Scott老师的视频走完了 视频最后是一个爬虫的小例子，和一个刷评论的方法，感觉so cool有木有，我还按照这个方法刷了下我的博客的回复，哈哈！ 然后我就空虚了，视频看完了，没啥感觉啊，离我的目标有点远啊。或许是因为理解的不够透彻，于是我又找了一些资料，如下： （暂时无用）大神的《Node.js 包教不包会》https://github.com/alsotang/node-lessons （学不明白）Scott老师的 node+mongodb 建站攻略（一期） （没啥用）极客学院的： Node.js 实战项目开发：极客学院“技术问答” （重点！）极客学院的： Node.js 实践： 使用 MongoDB 存储数据（可看23小节） 我们来按照我的过程捋一下： 《Node.js包教不包会》是我朋友推荐的，他说你看完了这些就入门啦，一开始几课还好，后来就很吃力了。而且感觉课程面挺广，目前初学者可能涉及不到那些，于是我决定先放放，等有了一定了解了再回来 然后我想到了Scott老师，他的视频感觉挺好啊，找找有没有其他的视频，然后找到了《node+mongodb 建站攻略（一期）》，哎呦，不仅学了node还学了数据库，就它了。看了一会发现，这个教程不适合初学者（别问我为什么，可能是我笨） 经过了上面两个坎坷后，有点抱怨人生了。然后又去撸了会儿安卓。其实之前的两步还是有收获的，只不过我可能上手有点慢？都是“浅尝辄止”了。 今天上午看了极客学院的nodejs实战项目开发后，心里逐渐有了个方向：服务器嘛，无非就是你给我个请求，我返回给你个数据。对于我这样的初学者来说，管你什么性能什么并发什么……现在能简单的做个数据交互就好！ 那我就需要两点： 解析请求 操作数据库 二人组express我把express理解为中间人，客户端和数据库的中间人，别人发来的请求，我通过express进行路由（我理解的路由就是：一个请求好比一车乘客，我路由就是把不同的乘客送到不同的家，即分发）、解析（知道这个请求是干啥的嘛） mongoDbexpress之后，自然而然就涉及到操作数据库了。于是我找了上面提到的视频教程《node.js实践：使用MongoDB》 注意事项视频第三节中，使用express * 初始化项目目录，而4.x以后，我们要单独的加入express-generator，所以 npm install express-generator 然后再express * 就可以使用了 可以说有了上面俩玩意儿，我就能搭建基本的服务器了。至于其他的，先甩到后面去，先把这两个弄懂了再说。","raw":null,"content":null,"categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://flowerfat.com/categories/Nodejs/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://flowerfat.com/tags/基础/"}]},{"title":"nodejs入门（二）Events","slug":"nodejs入门二1016","date":"2015-10-15T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/10/16/nodejs入门二1016/","link":"","permalink":"http://flowerfat.com/2015/10/16/nodejs入门二1016/","excerpt":"","keywords":null,"text":"相关 官网：https://nodejs.org/en/ API：https://nodejs.org/api/ 慕课网：进击Node.js基础（一）：http://www.imooc.com/learn/348 说点啥上次提到了 api中的Url与Http 。 这次我们继续跟着视频来走，看一下事件Events 上期回顾总结我们在看API的时候，发现有些方法里的参数是用’[]’包含起来的，包含起来的：非必要参数eg： emitter.removeAllListeners([event]) 如果event存在，则移除event相关的监听，如果enent不存在，就是移除所有的监听（大家看了视频就懂了） 先来看一段上篇文章的代码： http.get(url, function (res) { var html = &apos;&apos; res.on(&apos;data&apos;, function(data) { html += data }) res.on(&apos;end&apos;, function(){ filterChapters(html) }) }).on(&apos;error&apos;, function() { console.log(&apos;获取网站数据出错！&apos;) }) 当我看到这里的时候，我会问，data是啥啊？哪儿来的？这就要追溯到这次文章的男主Event了。 API 对应api地址：https://nodejs.org/api/events.html 对应视频地址：http://www.imooc.com/video/8525/0 EventsEvents Class: events.EventEmitter emitter.addListener(event, listener) emitter.on(event, listener) emitter.once(event, listener) emitter.removeListener(event, listener) emitter.removeAllListeners([event]) emitter.setMaxListeners(n) emitter.getMaxListeners() EventEmitter.defaultMaxListeners emitter.listeners(event) emitter.emit(event[, arg1][, arg2][, ...]) emitter.listenerCount(type) Class Method: EventEmitter.listenerCount(emitter, event) Event: &apos;newListener&apos; Event: &apos;removeListener&apos; Inheriting from &apos;EventEmitter&apos; PS:我总觉得api里的’,’和’[‘的位置反了。。。 emit事件的触发，与on搭配使用 emitter.emit(event, [arg1], [arg2], [...]) 参数 event：事件名 —– ‘event’ arg1：参数1 —— ‘参数1’ …… 不多说，直接来看下一个方法，我们搭配使用 on触发的响应，与emit搭配使用。相当于安卓中的setOn*Listener emitter.on(event, listener) 参数 event：事件名 —– ‘event’ listener:触发响应的具体执行 emit搭配onvar EventEmitter = require(&apos;events&apos;).EventEmitter var life = new EventEmitter() // 定义一个函数 function Hello(who){ console.log(&apos;hello &apos; + who) } life.on(&apos;welcome&apos;, function(who){ console.log(&apos;welcome &apos; + who) }) life.on(&apos;hello&apos;, Hello) life.emit(&apos;welcome&apos;, &apos;Bigflower&apos;) life.emit(&apos;hello&apos;, &apos;Bigflower&apos;) 最后一句调用后，立即执行event==welcome的事件所对应的函数，很容易理解，看视频大家就懂了。输出结果是： welcome Bigflower hello Bigflower remove即取消on中的Listener removeListener取消某个listener life.removeListener(&apos;hello&apos;, Hello) removeAllListener取消一堆listener life.removeAllListeners() // 取消所有的listener life.removeAllListeners(&apos;welcome&apos;) // 取消事件为welcome的所有listener EventEmitter.listenerCount获得某个事件event的listener数量 console.log(EventEmitter.listenerCount(life, &apos;welcome&apos;)) setMaxListeners(n)设置某个事件监听器的最大值，默认是10个（太多了可能会：内存泄漏（oh，从安卓跑到nodejs，还是离不开这玩意儿）） 相关文章nodejs入门（一）URL与HTTP http://www.flowerfat.com/2015/10/15/nodejs%E5%85%A5%E9%97%A8%E4%B8%801015/ nodejs入门（二）Eventshttp://www.flowerfat.com/2015/10/16/nodejs%E5%85%A5%E9%97%A8%E4%BA%8C1016/","raw":null,"content":null,"categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://flowerfat.com/categories/Nodejs/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://flowerfat.com/tags/基础/"}]},{"title":"nodejs入门（一）URL与HTTP","slug":"nodejs入门一1015","date":"2015-10-14T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/10/15/nodejs入门一1015/","link":"","permalink":"http://flowerfat.com/2015/10/15/nodejs入门一1015/","excerpt":"相关 官网：https://nodejs.org/en/ API：https://nodejs.org/api/ 慕课网：进击Node.js基础（一）：http://www.imooc.com/learn/348 说点啥一直想做一个属于自己的应用。于是“被迫”就来学一门后台相关的语言。以前从没搞过相关的，node应该算是我的启蒙语言了吧。 js嘛 很难想不到JavaScript，学会了这个，是不是再学Web就简单了？ 我是从慕课网看视频学起的，这篇文章算是学习笔记吧，视频地址见下面的相关 APIURL对应api地址：https://nodejs.org/api/url.html 对应慕课网视频地址：http://www.imooc.com/video/6710 api里乍一看啥玩意儿啊，全是英文，然后我就去看视频了。看完视频反过来再看api，卧槽，原来前面那一大坨Example是这个啊，哈哈，我们一起来看 我们在cmd中输入node，回车，便进入了nodejs的环境。 输入url，回车，我们会看到： { parse: [Function: urlParse], resolve: [Function: urlResolve], resolveObject: [Function: urlResolveObject], format: [Function: urlFormat], Url: [Function: Url] } 这就是我们url的几个方法。其中最重要的当属 parse 了。 api中如下，我也不懂。。。： url.parse(urlStr, [parseQueryString], [slashesDenoteHost]) parse基础作用：解析 url 输入：url.parse(‘http://www.flowerfat.com‘)输出： { protocol: &apos;http:&apos;, slashes: true, auth: null, host: &apos;www.flowerfat.com&apos;, port: null, hostname: &apos;www.flowerfat.com&apos;, hash: null, search: null, query: null, pathname: &apos;/&apos;, path: &apos;/&apos;, href: &apos;http://www.flowerfat.com/&apos; } 跟着视频走到这里的时候，虽然scott哥说了每个的含义，不过还是没咋懂啊！直到后来看到api我说的那一坨，哦吼，每个都有对应的解释啊。具体我就不多说了，英文也不难，大家一看就懂了","keywords":null,"text":"相关 官网：https://nodejs.org/en/ API：https://nodejs.org/api/ 慕课网：进击Node.js基础（一）：http://www.imooc.com/learn/348 说点啥一直想做一个属于自己的应用。于是“被迫”就来学一门后台相关的语言。以前从没搞过相关的，node应该算是我的启蒙语言了吧。 js嘛 很难想不到JavaScript，学会了这个，是不是再学Web就简单了？ 我是从慕课网看视频学起的，这篇文章算是学习笔记吧，视频地址见下面的相关 APIURL对应api地址：https://nodejs.org/api/url.html 对应慕课网视频地址：http://www.imooc.com/video/6710 api里乍一看啥玩意儿啊，全是英文，然后我就去看视频了。看完视频反过来再看api，卧槽，原来前面那一大坨Example是这个啊，哈哈，我们一起来看 我们在cmd中输入node，回车，便进入了nodejs的环境。 输入url，回车，我们会看到： { parse: [Function: urlParse], resolve: [Function: urlResolve], resolveObject: [Function: urlResolveObject], format: [Function: urlFormat], Url: [Function: Url] } 这就是我们url的几个方法。其中最重要的当属 parse 了。 api中如下，我也不懂。。。： url.parse(urlStr, [parseQueryString], [slashesDenoteHost]) parse基础作用：解析 url 输入：url.parse(‘http://www.flowerfat.com‘)输出： { protocol: &apos;http:&apos;, slashes: true, auth: null, host: &apos;www.flowerfat.com&apos;, port: null, hostname: &apos;www.flowerfat.com&apos;, hash: null, search: null, query: null, pathname: &apos;/&apos;, path: &apos;/&apos;, href: &apos;http://www.flowerfat.com/&apos; } 跟着视频走到这里的时候，虽然scott哥说了每个的含义，不过还是没咋懂啊！直到后来看到api我说的那一坨，哦吼，每个都有对应的解释啊。具体我就不多说了，英文也不难，大家一看就懂了 parse进阶输入：url.parse(‘http://www.flowerfat.com‘, true)第二个参数的目的：解析query时，是否用QueryString这个module。这个设置为true的时候，解析到的query就成了键值对的形式。 输入：url.parse(‘//www.flowerfat.com’, true)出问题了，host都得不到 输入：url.parse(‘//www.flowerfat.com’, true, true)结果正确了，第三个参数默认是false，这里设置成true ，就能正确解析了。这里我没懂，scott哥也没说这个参数是干啥的。不过我们来看api中：slashesDenoteHost是第三个参数的名字，百度了下，网上的说法是它会去认//与/，这两个中间的当作host。 具体我也不造理解的对不，又懂得朋友可以批评指教。 format作用：与parse相反，即把上面解析输出的结果丢到这个函数里，返回url输入 输入：url.format( {protocol: ‘http:’,……,path: ‘/‘,href: ‘http://www.flowerfat.com/‘ } );输出：’http://www.flowerfat.com‘ resolve作用：我理解是拼接，有一定规则的拼接 详情正如api里的Example： url.resolve(&apos;/one/two/three&apos;, &apos;four&apos;) // &apos;/one/two/four&apos; url.resolve(&apos;http://example.com/&apos;, &apos;/one&apos;) // &apos;http://example.com/one&apos; url.resolve(&apos;http://example.com/one&apos;, &apos;/two&apos;) // &apos;http://example.com/two&apos; Query Strings懂的人都知道，我们用get方法跟服务器交流的时候，’？’后面的请求参数很重要。那么这个问号后面的请求参数就是我们parse后的query的值 对应api地址：https://nodejs.org/api/querystring.html 对应慕课网视频地址：http://www.imooc.com/video/6711 stringify序列化：把键值对变成网址的形式 parse反序列化：相当于前面我们提到的url.parse方法中的第二个参数，这是为true escape、unescape转义和反转义 HTTP源码这可是个大工程，视频里在这部分说了一堆，我表示我睡着了。。。 中间部分都是一些需要了解的概念和知识，这些有助于我们后面关于HTTP源码的了解，这里就不赘述了。 对应api地址：https://nodejs.org/api/http.html 对应慕课网视频地址：http://www.imooc.com/video/7963 直接来看源码部分(源码来自Github！but！我在github上找不到视频里的那个工程啊，什么鬼，于是就选了个下面的这个，朋友们海涵) nodejs对应源码地址：https://github.com/nodejs/node 然后在github页面按下t, 就是工程的搜索功能！卧槽，这个有点厉害 然后搜索http.js，就是我们要的HTTP的源码了哈 var http = require(&apos;http&apos;) http .createServer(function(req, res) { res.writeHead(200, {&apos;Content-Type&apos;:&apos;text/plain&apos;}) res.write(&apos;Hello Ming&apos;) res.end() }) .listen(2015) 我表示这段真没啥好说的。视频里针对上面代码的由来，追踪了下github上的源码。十几分钟的视频下来我是懵圈了，根本不明所以。朋友们你们加油，不说了，都是泪。 HTTP 爬虫作为一个干活分享者，显然上面的乱七八糟的不是我的风格，这里继续copy视频里的好东西。 对应视频地址：http://www.imooc.com/video/7965 目的所谓爬数据，我理解就是把我们需要的东西get到。（其实爬网页对html也要有一定了解） 执行1为了方便爬，我们按照作者的意思，安装一个插件 ：npm install cheerio ，目的是快速找到我们要爬的数据 在网页上审查元素，找到我们想要的： // &lt;div class=&quot;mod-chapters&quot;&gt; // &lt;div class=&quot;chapter chapter-active&quot;&gt;...&lt;/div&gt; 后面的active表示这个item是否展开 // &lt;div class=&quot;chapter chapter-active&quot;&gt;...&lt;/div&gt; // &lt;div class=&quot;chapter&quot;&gt;...&lt;/div&gt; // &lt;div class=&quot;chapter&quot;&gt;...&lt;/div&gt; // &lt;div class=&quot;chapter&quot;&gt;...&lt;/div&gt; // &lt;/div&gt; 主要代码（不要问我res.on(‘data’, function(data)里的data是哪儿来的，下篇文章见）： var http = require(&apos;http&apos;) var cheerio = require(&apos;cheerio&apos;) var url = &apos;http://www.imooc.com/learn/348&apos; // 相当于main 我们在这里解析html function filterChapters(html){ var $ = cheerio.load(html) // 这个跟视频里的learnchapter不同，可能是慕课网改了吧 // 通过这个方法就拿到了类名 var chapters = $(&apos;.chapter&apos;) // 打印数组的长度 console.log(&apos;打印 &apos;+chapters.length) } http.get(url, function (res) { var html = &apos;&apos; res.on(&apos;data&apos;, function(data) { html += data }) res.on(&apos;end&apos;, function(){ filterChapters(html) }) }).on(&apos;error&apos;, function() { console.log(&apos;获取网站数据出错！&apos;) }) 我们引入了cheerio，并用它来更好的get对应的数据 这里我们看，跟之前的代码比较，就多了个函数：filterChapters在接收完毕网页后，把网页数据传到这个函数里，进行整理。 在cdm中执行上面的代码： node crawierPlus.js 打印结果如下： 打印 5 执行2显然一个数组长度不是我们想要的，继续，嘿咻嘿咻！由执行1看到，chapters这个“数组”就是我们要的内容了。我们继续解析，如何拿到标题呢？ 看网页的相关审查元素： chapters.each(function(item){ var chapter = $(this) var chapterTitle = chapter.find(&apos;strong&apos;).text() console.log(chapterTitle + &apos;\\n&apos;) }) 通过each方法，得到每个chapter。通过find的方法，得到strong，在.text()得到strong里的text再来看对应video的获取：从图上能看出，video下有两个对应的条目 chapters.each(function(item){ var chapter = $(this) var chapterTitle = chapter.find(&apos;strong&apos;).text() console.log(chapterTitle + &apos;\\n&apos;) var videos = chapter.find(&apos;.video&apos;).children(&apos;li&apos;) videos.each(function(item){ var video = $(this).find(&apos;.studyvideo&apos;) var videoTitle = video.text() var id = video.attr(&apos;href&apos;).split(&apos;video/&apos;)[1] console.log(&apos;【&apos;+id+&apos;】 &apos;+videoTitle) }) }) 对比上面的find方法，我们发现’strong’和’.video’有个不同点，’.video’前面有个’.’，大胆假设，因为video是一个class，而strong不是。故而有此区别跑一遍上面的code，我们就能看到一个很好看的结果了。 我们是打log，而视频里作者是把数据都封装到了一起，用的是push的方法，具体我也不懂，就不瞎bb了。 Codevar http = require(&apos;http&apos;) var cheerio = require(&apos;cheerio&apos;) var url = &apos;http://www.imooc.com/learn/348&apos; function filterChapters(html){ var $ = cheerio.load(html) var chapters = $(&apos;.chapter&apos;) var courseData = [] chapters.each(function(item){ var chapter = $(this) var chapterTitle = chapter.find(&apos;strong&apos;).text() var videos = chapter.find(&apos;.video&apos;).children(&apos;li&apos;) var chapterData = { chapterTitle: chapterTitle, videos:[] } videos.each(function(item){ var video = $(this).find(&apos;.studyvideo&apos;) var videoTitle = video.text() var id = video.attr(&apos;href&apos;).split(&apos;video/&apos;)[1] chapterData.videos.push({ title:videoTitle, id: id }) }) courseData.push(chapterData) }) return courseData } function printCourseInfo(courseData){ courseData.forEach(function(item){ var chapterTitle = item.chapterTitle console.log(chapterTitle + &apos;\\n&apos;) item.videos.forEach(function(video){ console.log(&apos; 【&apos;+video.id+&apos;】 &apos;+ video.title + &apos;\\n&apos;) }) }) } http.get(url, function (res) { var html = &apos;&apos; res.on(&apos;data&apos;, function(data) { html += data }) res.on(&apos;end&apos;, function(){ var courseData = filterChapters(html) printCourseInfo(courseData) }) }).on(&apos;error&apos;, function() { console.log(&apos;获取网站数据出错！&apos;) }) 相关文章nodejs入门（一）URL与HTTP http://www.flowerfat.com/2015/10/15/nodejs%E5%85%A5%E9%97%A8%E4%B8%801015/ nodejs入门（二）Eventshttp://www.flowerfat.com/2015/10/16/nodejs%E5%85%A5%E9%97%A8%E4%BA%8C1016/","raw":null,"content":null,"categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://flowerfat.com/categories/Nodejs/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://flowerfat.com/tags/基础/"}]},{"title":"Android Studio Junit单元测试","slug":"Junit单元测试1013","date":"2015-10-12T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/10/13/Junit单元测试1013/","link":"","permalink":"http://flowerfat.com/2015/10/13/Junit单元测试1013/","excerpt":"说点啥今天看了片文章：《程序员必看的六本书》 里面有个《单元测试的艺术》 ， 于是觉得有必要尝试经常使用下。 书还没买，不过先研究了下在AS中如何使用Junit如果你使用的是Eclipse，那么看这篇慕课网的文章吧： JUnit—Java单元测试必备工具 相关链接AS中没用过，只有百度了。 众说纷纭有木有。后来看到了这篇文章 使用Android Studio进行单元测试，是篇译文，原文是：Unit Testing With Android Stutio 一开始看译文没看懂，只能说自己笨吧。 其实按照他的思路一步一步走就可以了。写这篇文章只是Mark一下。 基本使用言归正传，我来说说重点吧：（最好走一遍上面的那文章再来看我的总结，每一小点在后面有配图） 给自己的测试文件专门安个家（创建个特定的package，方便以后统一删除） 在这个家里，创建一个我们的测试文件，注意要继承 InstrumentationTestCase 类 使用Edit Configurations进行Android Test的设置 运行 第一点-注解","keywords":null,"text":"说点啥今天看了片文章：《程序员必看的六本书》 里面有个《单元测试的艺术》 ， 于是觉得有必要尝试经常使用下。 书还没买，不过先研究了下在AS中如何使用Junit如果你使用的是Eclipse，那么看这篇慕课网的文章吧： JUnit—Java单元测试必备工具 相关链接AS中没用过，只有百度了。 众说纷纭有木有。后来看到了这篇文章 使用Android Studio进行单元测试，是篇译文，原文是：Unit Testing With Android Stutio 一开始看译文没看懂，只能说自己笨吧。 其实按照他的思路一步一步走就可以了。写这篇文章只是Mark一下。 基本使用言归正传，我来说说重点吧：（最好走一遍上面的那文章再来看我的总结，每一小点在后面有配图） 给自己的测试文件专门安个家（创建个特定的package，方便以后统一删除） 在这个家里，创建一个我们的测试文件，注意要继承 InstrumentationTestCase 类 使用Edit Configurations进行Android Test的设置 运行 第一点-注解 我理解的这个新包的作用，就是为了代码整洁，便于管理 第二点-注解 Calculate是我们待测试的文件，CalculateTest是我们创建的测试文件。右侧是测试文件的代码，很简单： public class CalculateTest extends InstrumentationTestCase { /** * 除法测试 * 这里的函数名 test() ，其实名字可以自己取，只不过有要求，开头必须以test开头，例如： * testDivide() &lt;--&gt; test() * 大家可以自己试试 * @throws Exception */ public void test() throws Exception { final int expected = 3; // 预计结果值 final int reality = new Calculate().divide(5,2); // 实际返回值 assertEquals(expected, reality); // 对比两个值 } } 待测试的代码是： public class Calculate { public int divide(int a, int b) { return a / b; } } 预计结果是我们觉得应该的返回值。 实际返回值是通过测试后的返回值。该测试运行后打印结果如下： 右上角的”进度条”是红色，说明出错了。如果你看到右上角是绿色的，you are right !我们期待结果是3，而实际除法算出的是2 。 第三点-注解配置这块，就看他的文章就好，说的很明白。 Target Device这里选第一个，就是弹出个框问你选什么手机来运行这个TestCase。默认是Emulator系统自带的模拟器，这个很慢啊。我们选了show chooser dialog后，就可以用Genymotion了。这说明跑测试文件也是需要手机的 进阶能不能测试网络请求呢？ 可是我的网络请求有两个回调函数啊，怎么破？一个Success的，一个Error的。后来一琢磨，你丫网络请求有啥可测的，而且返回值千变万化的。 那进阶里能有什么比较叼的内容呢？额，我也没想好。 其他给明明推荐了两首歌：阿明的《青春万岁》、好妹妹乐队的《我也可以是流浪诗人》，她问我，这就是民谣吗？怎么感觉调调都一样呢 ~","raw":null,"content":null,"categories":[{"name":"安卓","slug":"安卓","permalink":"http://flowerfat.com/categories/安卓/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"http://flowerfat.com/tags/无标签/"}]},{"title":"ContentProvider学习笔记","slug":"ContentProvider1009","date":"2015-10-08T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/10/09/ContentProvider1009/","link":"","permalink":"http://flowerfat.com/2015/10/09/ContentProvider1009/","excerpt":"说点啥原谅我这么晚才来了解这个名为安卓四大组件之一的家伙 -。-这个名字明显是两个英文拼一块儿的，内容、提供者。是个载体？ 简介我们本地存储的东西，可以用SharedPreferences,可以用数据库，可以用文件存储，但这些都是应用内的。那么如果我想将数据分享给其他程序呢（别问我为什么，开源也不是坏事）这时候主角就出现了：ContentProvider ContentResolver前言这玩意儿我们可以理解为：用它来使用ContentProvider，嗯 它是一个类。要使用它，首先要获得他的实例： ContentResolver cr = getContentResolver(); 然后我们就可以用这个 cr 为所欲为了~ insert() update() delete() query() 像不像数据库？四种方法：增删改查。 与数据库不同的是，它不是对表进行操作，而是Uri。不喜欢废话，来看一个小Demo, 敲自慕课网。 demo这是一个查询手机联系人的类","keywords":null,"text":"说点啥原谅我这么晚才来了解这个名为安卓四大组件之一的家伙 -。-这个名字明显是两个英文拼一块儿的，内容、提供者。是个载体？ 简介我们本地存储的东西，可以用SharedPreferences,可以用数据库，可以用文件存储，但这些都是应用内的。那么如果我想将数据分享给其他程序呢（别问我为什么，开源也不是坏事）这时候主角就出现了：ContentProvider ContentResolver前言这玩意儿我们可以理解为：用它来使用ContentProvider，嗯 它是一个类。要使用它，首先要获得他的实例： ContentResolver cr = getContentResolver(); 然后我们就可以用这个 cr 为所欲为了~ insert() update() delete() query() 像不像数据库？四种方法：增删改查。 与数据库不同的是，它不是对表进行操作，而是Uri。不喜欢废话，来看一个小Demo, 敲自慕课网。 demo这是一个查询手机联系人的类 package com.flowerfat.utiltool.Utils; import android.content.ContentResolver; import android.content.ContentUris; import android.content.ContentValues; import android.content.Context; import android.database.Cursor; import android.net.Uri; import android.provider.ContactsContract.CommonDataKinds.Email; import android.provider.ContactsContract.CommonDataKinds.Phone; import android.provider.ContactsContract.CommonDataKinds.StructuredName; import android.provider.ContactsContract.Contacts; import android.provider.ContactsContract.Data; import android.provider.ContactsContract.RawContacts; import android.util.Log; /** * Created by 明明大美女 on 2015/10/8. * 权限要求： * 写权限 android:name=&quot;android.permission.WRITE_CONTACTS&quot; * 读权限 android:name=&quot;android.permission.READ_CONTACTS&quot; * 教程： http://www.imooc.com/video/4041 */ public class ContactsUtil { public ContactsUtil() { } public static void getPhoneContacts(Context context) { ContentResolver cr = context.getContentResolver(); try { Cursor c = cr.query(Contacts.CONTENT_URI, new String[]{Contacts._ID, Contacts.DISPLAY_NAME}, null, null, null) ; if(c != null){ while (c.moveToNext()){ int id = c.getInt(c.getColumnIndex(&quot;_id&quot;)); Log.i(&quot;info&quot;, &quot;_id:&quot;+id ); Log.i(&quot;info&quot;, &quot;name:&quot;+ c.getString(c.getColumnIndex(&quot;display_name&quot;))); // 根据联系人id 查询电话号码 Cursor c1 = cr.query(Phone.CONTENT_URI, new String[]{Phone.NUMBER, Phone.TYPE}, Phone.CONTACT_ID+&quot;=&quot;+id, null, null); if(c1 != null){ while (c1.moveToNext()){ int type = c1.getInt(c1.getColumnIndex(Phone.TYPE)); if(type == Phone.TYPE_HOME){ Log.i(&quot;info&quot;, &quot;家庭电话:&quot;+c1.getString(c1.getColumnIndex(Phone.NUMBER))); } else if(type == Phone.TYPE_MOBILE){ Log.i(&quot;info&quot;, &quot;手机:&quot;+c1.getString(c1.getColumnIndex(Phone.NUMBER) )); } } c1.close(); } // 根据联系人ID 查询邮箱地址 Cursor c2 = cr.query(Email.CONTENT_URI, new String[]{Email.DATA, Email.TYPE}, Email.CONTACT_ID+&quot;=&quot;+id, null, null); if(c2 != null){ while (c2.moveToNext()){ int type = c2.getInt(c2.getColumnIndex(Email.TYPE)); if(type == Email.TYPE_WORK){ Log.i(&quot;info&quot;, &quot;工作邮箱:&quot;+c2.getString(c2.getColumnIndex(Email.DATA) )); } } c2.close(); } } c.close(); } } catch (Exception e){ return ; } } /** * 向联系人中插入一行数据 * 重复插入无效（即用了两次该函数，具体哪里的锅不晓得） * @param context */ public static void insertAContact(Context context){ ContentResolver cr = context.getContentResolver(); // 向联系人中插入一行数据 ContentValues values = new ContentValues(); Uri uri = cr.insert(RawContacts.CONTENT_URI, values); Long raw_contact_id = ContentUris.parseId(uri); values.clear(); // 插入人名 values.put(StructuredName.RAW_CONTACT_ID, raw_contact_id); values.put(StructuredName.DISPLAY_NAME, &quot;张三&quot;); values.put(StructuredName.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE); cr.insert(Data.CONTENT_URI, values); // 插入电话信息 values.clear(); values.put(Phone.RAW_CONTACT_ID, raw_contact_id); values.put(Phone.NUMBER, &quot;13888888888&quot;); values.put(Phone.MIMETYPE, Phone.CONTENT_ITEM_TYPE); cr.insert(Data.CONTENT_URI, values); } } 这个类拿来就能用，使用如下： private void contacts(){ // 查询 // ContactsUtil.getPhoneContacts(this); // 插入 ContactsUtil.insertAContact(this); } 这个类也只是可雏形，后期会完善，具体更新详见我的github over最近有点浮躁，节后综合症么？这篇博客其实不算笔记，麻痹具体咋回事儿都没说，不过我不想写了。。。 相关视频：http://www.imooc.com/video/4040 相关文章：http://blog.csdn.net/zuolongsnail/article/details/6566317","raw":null,"content":null,"categories":[{"name":"安卓","slug":"安卓","permalink":"http://flowerfat.com/categories/安卓/"}],"tags":[{"name":"控件","slug":"控件","permalink":"http://flowerfat.com/tags/控件/"}]},{"title":"多点触摸","slug":"多点触摸0924","date":"2015-09-23T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/09/24/多点触摸0924/","link":"","permalink":"http://flowerfat.com/2015/09/24/多点触摸0924/","excerpt":"说点啥今天在网上看到了个长按两个手指，然后执行 某某 操作的gif，感觉这个想法不错，于是自己试了下，先看图： DO检测按下onTouchListener没啥好说的： @Override public boolean onTouch(View v, MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.i(&quot;onTouch&quot;, &quot;DOWN X：&quot; + event.getX()); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;onTouch&quot;, &quot;MOVE X：&quot; + event.getX()); break; case MotionEvent.ACTION_UP: Log.i(&quot;onTouch&quot;, &quot;UP X：&quot; + event.getX()); break; } return true; } 平时我们用到的普通的触摸都是上面的Code。case后面跟了三种情况：按下，移动，抬起 检测多个点按下言归正传，我们要的是多点触摸，上面的只是一个点啊。所以case后面再来两种方法试试： MotionEvent.ACTION_POINTER_DOWN 和 MotionEvent.ACTION_POINTER_UP","keywords":null,"text":"说点啥今天在网上看到了个长按两个手指，然后执行 某某 操作的gif，感觉这个想法不错，于是自己试了下，先看图： DO检测按下onTouchListener没啥好说的： @Override public boolean onTouch(View v, MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.i(&quot;onTouch&quot;, &quot;DOWN X：&quot; + event.getX()); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;onTouch&quot;, &quot;MOVE X：&quot; + event.getX()); break; case MotionEvent.ACTION_UP: Log.i(&quot;onTouch&quot;, &quot;UP X：&quot; + event.getX()); break; } return true; } 平时我们用到的普通的触摸都是上面的Code。case后面跟了三种情况：按下，移动，抬起 检测多个点按下言归正传，我们要的是多点触摸，上面的只是一个点啊。所以case后面再来两种方法试试： MotionEvent.ACTION_POINTER_DOWN 和 MotionEvent.ACTION_POINTER_UP 完整代码： @Override public boolean onTouch(View v, MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.i(&quot;onTouch&quot;, &quot;DOWN X：&quot; + event.getX()); break; case MotionEvent.ACTION_MOVE: Log.i(&quot;onTouch&quot;, &quot;MOVE X：&quot; + event.getX()); break; case MotionEvent.ACTION_UP: Log.i(&quot;onTouch&quot;, &quot;UP X：&quot; + event.getX()); break; case MotionEvent.ACTION_POINTER_DOWN: Log.i(&quot;多点&quot;,&quot;多点down&quot; + event.getX()); break ; case MotionEvent.ACTION_POINTER_UP: Log.i(&quot;多点&quot;, &quot;多点up&quot; + event.getX()); break ; } return true; } 后面两个就是多点的时候触发的了。然并卵啊。什么鬼？POINTER_DOWN检测不到。后来百度到了这个东西 MotionEvent.ACTION_MASK： switch (event.getAction() &amp; MotionEvent.ACTION_MASK) 说是一个动作掩码，具体怎么我也没看懂，目前就理解为多点触摸就要用它，就！要！用！ @Override public boolean onTouch(View v, MotionEvent event) { switch (event.getAction() &amp; MotionEvent.ACTION_MASK) { ... ... } return true; } 获得两个点的位置 getX(i)终于可以检测到多点触摸了的按下和抬起了，但是怎么获得我两个点的坐标呢？之前的event.getX()只有一个值啊！看event.getX()的源码我们会发现： /** * {@link #getX(int)} for the first pointer index (may be an * arbitrary pointer identifier). * * @see #AXIS_X */ public final float getX() { return nativeGetAxisValue(mNativePtr, AXIS_X, 0, HISTORY_CURRENT); } 注释中提到：first pointer index， 也就是说getX()获得的是第一个点的X坐标，再深入 private static native float nativeGetAxisValue(long nativePtr, int axis, int pointerIndex, int historyPos); 这里有个变量 pointerIndex ， 显然就是触摸点的index嘛， getX()默认的pointerIndex为0，所以就是获取第一个点了。那么就是event.getX(i)了 public final float getX(int pointerIndex) { return nativeGetAxisValue(mNativePtr, AXIS_X, pointerIndex, HISTORY_CURRENT); } over相关链接： http://blog.csdn.net/bigconvience/article/details/26611003","raw":null,"content":null,"categories":[{"name":"安卓","slug":"安卓","permalink":"http://flowerfat.com/categories/安卓/"}],"tags":[{"name":"控件","slug":"控件","permalink":"http://flowerfat.com/tags/控件/"}]},{"title":"开源项目MakePoint~","slug":"开源项目Make Point","date":"2015-09-22T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/09/23/开源项目Make Point/","link":"","permalink":"http://flowerfat.com/2015/09/23/开源项目Make Point/","excerpt":"","keywords":null,"text":"说点啥看了标题，你以为是某个叼叼的开源项目，那你就错了。哈哈，是我的第一个开源项目。 贴图 github地址https://github.com/mBigFlower/MakePoint 简介今日事，今日毕。每天定义四个重要的事情，mark在这里。 四件事分为四个重要等级，灵感来自爱情公寓–关谷和悠悠, 姹紫嫣红~~~~ APK下载 to be continued …","raw":null,"content":null,"categories":[{"name":"github","slug":"github","permalink":"http://flowerfat.com/categories/github/"}],"tags":[{"name":"android","slug":"android","permalink":"http://flowerfat.com/tags/android/"}]},{"title":"友盟社会化分享（一） QQ、微信","slug":"社会化分享0825","date":"2015-08-24T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/25/社会化分享0825/","link":"","permalink":"http://flowerfat.com/2015/08/25/社会化分享0825/","excerpt":"工具：studio 前言这篇文章讲的是如何使用友盟的社会化分享，因为第一次用友盟，所以把步骤写下来，以后方便用，肯定比官方的文档直观的多。无非就是jar包和res资源了，是从官网下载的，他还推荐一个什么SDKIntegration.jar可以帮助你自动导入这两个的。我用了下还真可以。不过对于Manifest就没啥用了。 准备 在友盟官网下载相关sdk 在你要分享的平台注册开发者帐号，在里面创建应用。具体操作后面说 准备好你的包名；debug版本，release版本的SHA1，MD5 老大哥–友盟libs umeng_social_sdk.jar 这个是老大哥，负责一揽子业务 httpmime-4.1.3.jar res我尼玛！用了SDKIntegration.jar自动导入后，res里面的drawable加了一堆乱造的东西进去，什么豆瓣人人共73个文件，layout里也一堆，哪些有用我都不知道，到现在我也不知道哪些有用哪些没用，暂且先不管了，听大哥的。把功能都实现先。 Manifest.xml注意里面的APPKEY，你在友盟创建应用的时候他就会给你一个，把value里换成你的哈 &lt;!--友盟社会化分享--&gt; &lt;meta-data android:name=&quot;UMENG_APPKEY&quot; android:value=&quot;Your appkey&quot; /&gt; &lt;activity android:name=&quot;com.umeng.socialize.view.ShareActivity&quot; android:configChanges=&quot;orientation|keyboard&quot; android:launchMode=&quot;singleTask&quot; android:noHistory=&quot;true&quot; android:theme=&quot;@style/Theme.UMDialog&quot; android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot; /&gt;","keywords":null,"text":"工具：studio 前言这篇文章讲的是如何使用友盟的社会化分享，因为第一次用友盟，所以把步骤写下来，以后方便用，肯定比官方的文档直观的多。无非就是jar包和res资源了，是从官网下载的，他还推荐一个什么SDKIntegration.jar可以帮助你自动导入这两个的。我用了下还真可以。不过对于Manifest就没啥用了。 准备 在友盟官网下载相关sdk 在你要分享的平台注册开发者帐号，在里面创建应用。具体操作后面说 准备好你的包名；debug版本，release版本的SHA1，MD5 老大哥–友盟libs umeng_social_sdk.jar 这个是老大哥，负责一揽子业务 httpmime-4.1.3.jar res我尼玛！用了SDKIntegration.jar自动导入后，res里面的drawable加了一堆乱造的东西进去，什么豆瓣人人共73个文件，layout里也一堆，哪些有用我都不知道，到现在我也不知道哪些有用哪些没用，暂且先不管了，听大哥的。把功能都实现先。 Manifest.xml注意里面的APPKEY，你在友盟创建应用的时候他就会给你一个，把value里换成你的哈 &lt;!--友盟社会化分享--&gt; &lt;meta-data android:name=&quot;UMENG_APPKEY&quot; android:value=&quot;Your appkey&quot; /&gt; &lt;activity android:name=&quot;com.umeng.socialize.view.ShareActivity&quot; android:configChanges=&quot;orientation|keyboard&quot; android:launchMode=&quot;singleTask&quot; android:noHistory=&quot;true&quot; android:theme=&quot;@style/Theme.UMDialog&quot; android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot; /&gt; 小弟QQ—好友与空间获取QQ互联的APPKEY和APPID QQ互联的分享不需要签名啊，SHA1啊，MD5啊啥的。你在腾讯开放平台注册个开发者帐号，用自己的QQ也行。创建应用，未提交审核也可以哈 不提交审核，只有某些帐号可以测试的，我们可以自行来设置，首先点进我们的应用（在上图左侧方框左边点击，截图中未显示出来），点进去后如下操作： libs SocialSDK_QQZone_1.jar SocialSDK_QQZone_2.jar SocialSDK_QQZone_3.jar 还有个v4包，我没列出来哈，没啥说的 res还好这里只有一个图片包，就四张图片，要是像大哥那么多玩意儿，我就放弃友盟了！！！ Manifest.xml&lt;!-- 腾讯SSO授权的Activity注册 --&gt; &lt;activity android:name=&quot;com.tencent.tauth.AuthActivity&quot; android:launchMode=&quot;singleTask&quot; android:noHistory=&quot;true&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;tencent9999999999&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;com.tencent.connect.common.AssistActivity&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot; /&gt; 看到我的9999999999没？这里是个坑，应该换成你的appid。我从它的demo里复制过来后没注意，没改这个数字，分享没问题，但是会出现返回后出错啊。后来看官方的文档有这么一段话： 分享 初始化 private void QQInit(){ // 添加QQ支持, 并且设置QQ分享内容的target url UMQQSsoHandler qqSsoHandler = new UMQQSsoHandler(this, appId, appKey); qqSsoHandler.setTargetUrl(&quot;http://www.umeng.com/social&quot;); // 分享的链接 qqSsoHandler.addToSocialSDK(); // 添加QZone平台 QZoneSsoHandler qZoneSsoHandler = new QZoneSsoHandler(this, appId, appKey); qZoneSsoHandler.addToSocialSDK(); } 调起 private void addQZoneQQPlatform() { mController.getConfig().setPlatforms( SHARE_MEDIA.QQ, SHARE_MEDIA.QZONE); mController.openShare(this, false); } 这个setPlatforms里面可以加很多平台因为这里只涉及了两个，所以只。。。这个函数执行之后，就弹出了友盟的一个界面，如下图： 然后就没有然后了，已经ok了 强调 先说一点哈，有些基础的设置，友盟相关的，看最上面的友盟部分","raw":null,"content":null,"categories":[{"name":"安卓","slug":"安卓","permalink":"http://flowerfat.com/categories/安卓/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://flowerfat.com/tags/分享/"}]},{"title":"天气预报（四）","slug":"天气预报4-0822","date":"2015-08-21T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/22/天气预报4-0822/","link":"","permalink":"http://flowerfat.com/2015/08/22/天气预报4-0822/","excerpt":"","keywords":null,"text":"前言上次说到了中国气象平台的api没心情做，最近研究了它的api，还真有点头疼。。。 正文接口根据他官网的说法，看起来还挺简单的 调用规范 规范用于指导三方合作伙伴合理调用指数、3天常规预报(24小时)预报服务数据。请求方式：http get接口组成：由固定URL加5个不同的参数组成，完整URL需客户端经过固定方式加密后使用。数据返回：json完整URL：http://open.weather.com.cn/data/?areaid=&quot;&quot;&amp;type=&quot;&quot;&amp;date=&quot;&quot;&amp;appid=&quot;&quot;&amp;key=&quot;.urlencode($key);固定URL：http://open.weather.com.cn/data/ 其他都好说，就是那个最后的key的编码是怎么个回事儿？他官方的示例demo有方法，不过一开始我没看到，就找了个网友的类，别说还挺好用，哈哈，code如下： import android.util.Base64; import android.util.Log; import java.net.URLEncoder; import java.text.SimpleDateFormat; import java.util.Date; import javax.crypto.Mac; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; /** * Created by 明明大美女 on 2015/8/22. */ public class SmartWeatherUrlUtil { private final static String TAG = &quot;WeatherUrlUtil&quot;; private static final String MAC_NAME = &quot;HmacSHA1&quot;; private static final String ENCODING = &quot;UTF-8&quot;; private static final String appid = &quot;34b8c9f1ece084a7&quot;; private static final String private_key = &quot;46d458_SmartWeatherAPI_95941da&quot;; private static final String url_header=&quot;http://open.weather.com.cn/data/?&quot;; /** * 使用 HMAC-SHA1 签名方法对对encryptText进行签名 * * @param url * 被签名的字符串 * @param privatekey * 密钥 * @return * @throws Exception */ private static byte[] HmacSHA1Encrypt(String url, String privatekey) throws Exception { byte[] data = privatekey.getBytes(ENCODING); // 根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称 SecretKey secretKey = new SecretKeySpec(data, MAC_NAME); // 生成一个指定 Mac 算法 的 Mac 对象 Mac mac = Mac.getInstance(MAC_NAME); // 用给定密钥初始化 Mac 对象 mac.init(secretKey); byte[] text = url.getBytes(ENCODING); // 完成 Mac 操作 return mac.doFinal(text); } /** * 获取URL通过privatekey加密后的码 * @param url * @param privatekey * @return * @throws Exception */ private static String getKey(String url, String privatekey) throws Exception { byte[] key_bytes = HmacSHA1Encrypt(url, privatekey); String base64encoderStr = Base64.encodeToString(key_bytes, Base64.NO_WRAP); return URLEncoder.encode(base64encoderStr, ENCODING); } /** * 获得接口的URL地址 * @param areaid * @param type * @param date * @return * @throws Exception */ private static String getInterfaceURL(String areaid,String type,String date) throws Exception{ String keyurl=url_header+&quot;areaid=&quot;+areaid+&quot;&amp;type=&quot;+type+&quot;&amp;date=&quot;+date+&quot;&amp;appid=&quot;; String key=getKey(keyurl+appid,private_key); String appid6 = appid.substring(0, 6); return keyurl+appid6+&quot;&amp;key=&quot; + key; } public static String getInterfaceURL(String areaid, String type){ SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyyMMddhhmm&quot;); String date = dateFormat.format(new Date()); //String type=&quot;forecast3d&quot;;//&quot;index&quot;;//&quot;forecast3d&quot;;&quot;observe&quot; try { return getInterfaceURL(areaid,type,date); } catch (Exception e) { Log.e(TAG, e.getMessage(), e.fillInStackTrace()); } return null; } } 用起来很方便 String url = SmartWeatherUrlUtil.getInterfaceURL(cityId, Type) ; 回参话说这个也真是蛋疼，返回就没有个“准信”，非要整些玄乎的，也不知道图啥。我们来看返回的参数 简直不忍直视。。。 于是又去网上淘了写宝贝，如下： 回参倒是搞明白了，那里面的编号又是啥？风向的编号：天气的编号 图片可能有点小，大家自行去官网看哈 那么这个就告一段落了。话说最近这个是免费的啊。赶紧去购买，指不定就什么时候收费了 结尾我也没注意有没有把天气的返回值对应表直接写成工具类的，以后有了再更新哈，不想去淘了。我想关于接口应该就写这么多了，下一步应该就是界面和数据处理了，有空再更新哈。 链接天气预报（四） http://www.flowerfat.com/2015/08/22/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A54-0822/天气预报（三） http://www.flowerfat.com/2015/08/13/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0813/天气预报（二） http://www.flowerfat.com/2015/08/12/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0812/天气预报（一） http://www.flowerfat.com/2015/08/11/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0811/","raw":null,"content":null,"categories":[{"name":"安卓","slug":"安卓","permalink":"http://flowerfat.com/categories/安卓/"}],"tags":[{"name":"天气预报","slug":"天气预报","permalink":"http://flowerfat.com/tags/天气预报/"}]},{"title":"让控件动起来","slug":"Activity启动动画","date":"2015-08-21T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/22/Activity启动动画/","link":"","permalink":"http://flowerfat.com/2015/08/22/Activity启动动画/","excerpt":"","keywords":null,"text":"前言直接上图，简单粗暴 当然我们这里只是一个小demo，介绍某一个控件产生这种效果。操作很简单，不超过十行(加粗的部分是不是很诱人-。-) 效果一重点重点是要在activity出现之前，让里面的控件挨个动画显示出来。当然你可以说我一开始都是View.GONE，然后挨个让它们可见并带上动画，我承认这样可以。。。。。。不过这里我们还是学习一个专业点的方法哈。原文是在这里 code给我们要产生动画的控件 //插值器 也可以自行定义 private static final Interpolator INTERPOLATOR = new AccelerateInterpolator(); cardView1.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() { @Override public boolean onPreDraw() { cardView1.getViewTreeObserver().removeOnPreDrawListener(this); animInit(); // animAlpha(); return false; } }); 动画1：从上到下 /** * 动画的执行 */ private void animInit(){ cardView1.setTranslationY(-cardView1.getHeight()); // 这里可能位置不准确，大家自行调整 cardView1.animate().translationY(0).setDuration(700).setInterpolator(INTERPOLATOR); } 动画2：逐渐显示（透明度） private void animAlpha(){ cardView1.setAlpha(0); cardView1.animate().alpha(1).setDuration(700).setStartDelay(400).setInterpolator(INTERPOLATOR).start(); }","raw":null,"content":null,"categories":[{"name":"安卓","slug":"安卓","permalink":"http://flowerfat.com/categories/安卓/"}],"tags":[{"name":"控件","slug":"控件","permalink":"http://flowerfat.com/tags/控件/"}]},{"title":"强，软，弱，虚引用","slug":"软引用","date":"2015-08-19T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/20/软引用/","link":"","permalink":"http://flowerfat.com/2015/08/20/软引用/","excerpt":"","keywords":null,"text":"前言很早就听说过，但一直没有系统的看下，今天就来深入，咳咳，深入研究 分类 强引用 – 平时我们常用的 弱引用 – Weak Reference 软引用 – SoftReference 虚引用 – PhantomRefrence 强引用以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。上面这段文字出自 软引用有个哥们举这样一个例子：生活中，你可能会遇到类似鸡肋一样的物品，食之无味，弃之可惜。这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因为也许将来还会派用场。对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，就先把它保留在家里，如果家里空间不够，即使把家里所有的垃圾清除，还是无法容纳那些必不可少的生活用品（强引用的），那么再扔掉这些可有可无的物品。 这篇文章 提到，其实软引用主要是与OOM挂钩的（没经历过OOM的朋友，要么你一出生就带了主角光环，要么你还年轻） 使用SoftReference去实例化一个对象T SoftReference&lt;T&gt; sr = new SoftReference&lt;T&gt;(t) ; 获取t的时候，是通过get()的方法获取的 T t2 = sr.get(); 按照笔者的说法，当出现内存不足的时候，软引用就会被回收掉。既然这么好，我没每次，所有的都用它不就可以避免OOM了？ 图样图森破，它保证内存安全的同时，是牺牲了效率的。这点就需要大家具体问题具体来搞了。比如最常见的就是用在Bitmap下面是笔者的一段Bitmap的小例： import java.lang.ref.SoftReference; import java.util.Collections; import java.util.HashMap; import java.util.Map; import android.graphics.Bitmap; public class MemoryCache { //将HashMap封装成一个线程安全的集合，并且使用软引用的方式防止OOM（内存不足）... //由于在ListView中会加载大量的图片.那么为了有效的防止OOM导致程序终止的情况... private Map&lt;String,SoftReference&lt;Bitmap&gt;&gt;cache=Collections.synchronizedMap(new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;()); public Bitmap get(String id){ if(!cache.containsKey(id)) return null; SoftReference&lt;Bitmap&gt;ref=cache.get(id); return ref.get(); } public void put(String id,Bitmap bitmap){ cache.put(id, new SoftReference&lt;Bitmap&gt;(bitmap)); } public void clear(){ cache.clear(); } } 弱引用但凡被gc发现了，GG 。辣么，这个虚引用的作用在哪儿呢？弱引用最常用于实现规范化的映射 虚引用我是看了这篇文章 用来判断对象是否被回收了？虚引用使用场景主要由两个。它允许你知道具体何时其引用的对象从内存中移除。而实际上这是Java中唯一的方式。这一点尤其表现在处理类似图片的大文件的情况。当你确定一个图片数据对象应该被回收，你可以利用虚引用来判断这个对象回收之后再继续加载下一张图片。这样可以尽可能地避免可怕的内存溢出错误。 第二点我没看懂，这里就不bb了（我感觉用了虚引用，就怎么都不能再找回来了。其他的可以从引用队列中找到？）第二点，虚引用可以避免很多析构时的问题。finalize方法可以通过创建强引用指向快被销毁的对象来让这些对象重新复活。然而，一个重写了finalize方法的对象如果想要被回收掉，需要经历两个单独的垃圾收集周期。在第一个周期中，某个对象被标记为可回收，进而才能进行析构。但是因为在析构过程中仍有微弱的可能这个对象会重新复活。这种情况下，在这个对象真实销毁之前，垃圾回收器需要再次运行。因为析构可能并不是很及时，所以在调用对象的析构之前，需要经历数量不确定的垃圾收集周期。这就意味着在真正清理掉这个对象的时候可能发生很大的延迟。这就是为什么当大部分堆被标记成垃圾时还是会出现烦人的内存溢出错误。","raw":null,"content":null,"categories":[{"name":"安卓","slug":"安卓","permalink":"http://flowerfat.com/categories/安卓/"}],"tags":[]},{"title":"nothing","slug":"注册登录界面-0819","date":"2015-08-18T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/19/注册登录界面-0819/","link":"","permalink":"http://flowerfat.com/2015/08/19/注册登录界面-0819/","excerpt":"","keywords":null,"text":"坑1：Fragment与Activity目标：一个Activity中加入一个Fragment。坑： 一开始可以运行的，后来突然就报错了详细如下：xml &lt;FrameLayout android:id=&quot;@+id/signup_fragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:name=&quot;cn.com.idrv.godrive.activity.SignupFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; tools:layout=&quot;@layout/fragment_signup&quot; /&gt; &lt;/FrameLayout&gt; java就没啥说的里，里面都没东西，错误是： android.view.InflateException: Binary XML file line #12: Error inflating class fragment at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2325) 编译是不会报错的，但是跑起来就出错。 原因：系统新建Activity的时候默认继承的是废弃的ActionBarActivity。废弃后被画了个横线啊有木有，各种不爽，于是手贱给改成了Activity。 解决方法：用FragmentActivity或者直接用AppCompatActivity 坑2使用布局中的fragment不靠谱啊！！！看上面的那段代码： &lt;FrameLayout android:id=&quot;@+id/signup_fragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:name=&quot;cn.com.idrv.godrive.activity.SignupFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; tools:layout=&quot;@layout/fragment_signup&quot; /&gt; &lt;/FrameLayout&gt; 当我想要换Fragment的时候，我们在代码中这样： 当我们使用了replace后，坑爹的事情发生了，丫的旧的Fragment还在啊，如下图：Hello blank fragment 解决方法：索性不在布局里使用 了 ，直接在java里add一个进来 坑3今天打算把Volley框架加入到工程中，谁知道一copy进工程，就报错： F:\\android\\java\\jdk1.8.0_40\\bin\\java.exe&apos;&apos; finished with non-zero exit value 2 这什么鬼？我也没动过jdk啊。 我又copy一个Glide进工程，没事儿啊，可以啊。后知后觉！ 原来我在build.gradle里加入了一个github上一个哥们的Volley框架了 compile ‘com.mcxiaoke.volley:library:1.0.18’ 这时候再弄一个Volley进来 ，冲突了。 注释掉 complie，果断成功了！","raw":null,"content":null,"categories":[{"name":"安卓","slug":"安卓","permalink":"http://flowerfat.com/categories/安卓/"}],"tags":[]},{"title":"带Progress的BaseNetActivity","slug":"带Progress的BaseNetActivity","date":"2015-08-17T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/18/带Progress的BaseNetActivity/","link":"","permalink":"http://flowerfat.com/2015/08/18/带Progress的BaseNetActivity/","excerpt":"功能BaseNetActivity，继承AppCompatActivity。请求服务器成功后则显示layout内容，失败则显示‘加载失败’（点击加载失败可重新加载） 思路使用一个baseLayout，包含progress、mainLayout的“容器”、加载失败的内容显示 三部分。最开始显示进度，同时请求网络，成功或失败后隐藏progress，同时显示对应的内容 实现layout_base直接上布局： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/layoutBase_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; android:theme=&quot;@style/ThemeToolbar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; &lt;TextView android:id=&quot;@+id/layoutBase_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:visibility=&quot;gone&quot; android:drawableTop=&quot;@drawable/bili_net_wrong&quot; android:drawablePadding=&quot;27dp&quot; android:text=&quot;加载失败---&quot;/&gt; &lt;ViewStub android:id=&quot;@+id/layoutBase_viewStub&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;android.support.v4.widget.ContentLoadingProgressBar android:id=&quot;@+id/layoutBase_progress&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;?android:attr/progressBarStyleLarge&quot; android:layout_gravity=&quot;center&quot;/&gt; &lt;/FrameLayout&gt; 这里我们的标题使用的是Toolbar，大家也可以自定义，至于toolbar里面的theme等参数，可有可无的东西，不详说 除了标题，就是我刚刚提到的三个部分了，ViewStub 这东西懂的人都懂，好东西。用它的目的是少一层嵌套，也是今天我无意中想到的。","keywords":null,"text":"功能BaseNetActivity，继承AppCompatActivity。请求服务器成功后则显示layout内容，失败则显示‘加载失败’（点击加载失败可重新加载） 思路使用一个baseLayout，包含progress、mainLayout的“容器”、加载失败的内容显示 三部分。最开始显示进度，同时请求网络，成功或失败后隐藏progress，同时显示对应的内容 实现layout_base直接上布局： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/layoutBase_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; android:theme=&quot;@style/ThemeToolbar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; &lt;TextView android:id=&quot;@+id/layoutBase_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:visibility=&quot;gone&quot; android:drawableTop=&quot;@drawable/bili_net_wrong&quot; android:drawablePadding=&quot;27dp&quot; android:text=&quot;加载失败---&quot;/&gt; &lt;ViewStub android:id=&quot;@+id/layoutBase_viewStub&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;android.support.v4.widget.ContentLoadingProgressBar android:id=&quot;@+id/layoutBase_progress&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;?android:attr/progressBarStyleLarge&quot; android:layout_gravity=&quot;center&quot;/&gt; &lt;/FrameLayout&gt; 这里我们的标题使用的是Toolbar，大家也可以自定义，至于toolbar里面的theme等参数，可有可无的东西，不详说 除了标题，就是我刚刚提到的三个部分了，ViewStub 这东西懂的人都懂，好东西。用它的目的是少一层嵌套，也是今天我无意中想到的。 BaseNetActivity直接上代码，就是这么简单粗暴，详解我们后面再说 import android.os.Bundle; import android.support.annotation.LayoutRes; import android.support.v4.widget.ContentLoadingProgressBar; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import android.view.View; import android.view.ViewStub; import android.widget.TextView; import com.flowerfat.majiang.R; import butterknife.ButterKnife; /** * @author BigFlower * @ClassName: BaseNetActivity * @Description: TODO */ public abstract class BaseNetActivity extends AppCompatActivity { protected static String TAG ; private ContentLoadingProgressBar mProgress; private TextView errorTextView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.layout_base); TAG = this.getClass().getSimpleName(); initView(); init(); http(); } /** * 使用这个BaseNet， 就必须调用一开始就http的操作, * 不然就使用BaseActivity就好 */ public abstract void init(); public abstract void http(); /** * 初始化title的toolbar * * @param title 标题name */ protected void initToolbar(String title) { Toolbar toolbar = (Toolbar) findViewById(R.id.layoutBase_toolbar); toolbar.setTitle(title); setSupportActionBar(toolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); } private void initView() { mProgress = (ContentLoadingProgressBar) findViewById(R.id.layoutBase_progress); } /** * http成功后调用 * 隐藏progress，显示布局 * * @param res */ protected void setSuccess(@LayoutRes int res) { mProgress.hide(); ViewStub viewStub = (ViewStub) findViewById(R.id.layoutBase_viewStub); viewStub.setLayoutResource(res); viewStub.setVisibility(View.VISIBLE); ButterKnife.bind(this); } /** * http失败后调用 * 隐藏progress, 显示失败的布局 */ protected void setError() { mProgress.hide(); if (errorTextView == null){ errorTextView = (TextView) findViewById(R.id.layoutBase_text); errorTextView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { showProgress(); http(); } }); } errorTextView.setVisibility(View.VISIBLE); } private void showProgress(){ errorTextView.setVisibility(View.GONE); mProgress.show(); } @Override protected void onDestroy() { super.onDestroy(); // 这个一定不能少！ if (mProgress != null) { mProgress.hide(); } } } 详解之前的综述 使用方法简单，直接继承就好 public class BaseActTest extends BaseNetActivity { … } 代码里我们使用了ButterKnife，因为项目里用到，所以这里顺便也加进去了。它的初始化是为了BaseActTest准备的，不用的朋友去掉就好。不过去掉之后这个还能不能正常运作就不晓得了。有空我再验证下。 onCreateprotected static String TAG ; private ContentLoadingProgressBar mProgress; private TextView errorTextView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.layout_base); TAG = this.getClass().getSimpleName(); initView(); init(); http(); } TAG就不多说了，这个父类中定义一个，子类直接拿来用就好，这么做方便省事儿 顶部定义了两个控件，是三部分中的两部分 onCreate中，先是setContentView我们的layout_base布局，再给TAG赋值，这都简单 最后两个函数后面再说，initView()里面就一句话，是获得我们的mProgress private void initView() { mProgress = (ContentLoadingProgressBar) findViewById(R.id.layoutBase_progress); } 强制重写的两个函数init(),http()这里我要说明下，之所以要强制，是因为有需求！init();一来，方便，直接帮你写了个初始化的函数，你需要初始化的内容直接加进来就好。二来，因为重写了BaseNetActivity后就不需要在我们的子类里使用onCreate了，总得要个入口嘛，init()就是入口。http();不用说了，你既然用了这个就肯定要一开始就http网络请求的嘛。有的人会很不爽了，我们直接在init()里写http请求不行吗？为毛非要重写你的http()？因为当我们加载失败后，需要点击重新进行服务器请求！怎么通过父类的点击事件来调用子类的请求呢？我试过接口啥啥的，感觉这样最好，那就是让子类重写父类。这样我们在父类中调用http()，自然就执行了子类中的请求内容。看下面 setError()/** * http失败后调用 * 隐藏progress, 显示失败的布局 */ protected void setError() { mProgress.hide(); if (errorTextView == null){ errorTextView = (TextView) findViewById(R.id.layoutBase_text); errorTextView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { showProgress(); // 显示progress http(); } }); } errorTextView.setVisibility(View.VISIBLE); } 里面的 if 判断，是为了提高性能，避免重复的获取控件和增加点击监听。我们会看到点击时间里面，执行了 http() ，这就是我们上面提到的，父类中调用子类的内容。 setSuccess(@LayoutRes int res)/** * http成功后调用 * 隐藏progress，显示布局 * * @param res */ protected void setSuccess(@LayoutRes int res) { mProgress.hide(); ViewStub viewStub = (ViewStub) findViewById(R.id.layoutBase_viewStub); viewStub.setLayoutResource(res); viewStub.setVisibility(View.VISIBLE); ButterKnife.bind(this); } 显示获取控件，然后把布局加载进去，@LayoutRes 说明参数必须是layout资源。最后的ButterKnife前文提过哈。 使用前面说了这么多，来看使用，我们用Handler来模拟网络请求 public class BaseActTest extends BaseNetActivity { // R.layout.activity_base_act_test中的TextView @Bind(R.id.justATest) TextView tv; Handler mHandler = new Handler(); @Override public void init() { initToolbar(&quot;测试BaseNet&quot;); // 初始化标题 } @Override public void http() { Util.i(&quot;调用测试&quot;, &quot;zi类的&quot;); mHandler.postDelayed(new Runnable() { @Override public void run() { Util.i(&quot;调用测试&quot;, &quot;执行了&quot;); setError(); // setSuccess(R.layout.activity_base_act_test); // tv.setText(&quot;加载成功！&quot;); } }, 3000); } } R.layout.activity_base_act_test 我就不贴出来了哈，so easy !","raw":null,"content":null,"categories":[{"name":"android","slug":"android","permalink":"http://flowerfat.com/categories/android/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://flowerfat.com/tags/工具/"}]},{"title":"安卓开发，相见恨晚的小技巧","slug":"安卓开发，那些相见恨晚的接口，类","date":"2015-08-16T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/17/安卓开发，那些相见恨晚的接口，类/","link":"","permalink":"http://flowerfat.com/2015/08/17/安卓开发，那些相见恨晚的接口，类/","excerpt":"前言今天周一，开始干活喽~ 本文摘自鸿洋大哥转发的一片知乎上的文章 原文链接 我挑了一些我喜欢的我懂了的放在这里mark下 正文 View中的isShown()方法，以前都是用view.getVisibility() == View.VISIBLE来判断的(╯□╰)； Arrays类中的asList(T… array)方法，数组转List集合；反过来List.toArray()； android.media.ThumbnailUtils类，用来获取媒体（图片、视频）缩略图； TextUtils类中的isEmpty(String)方法，判断字符串是否为null或””；（原来有自带的啊。。）","keywords":null,"text":"前言今天周一，开始干活喽~ 本文摘自鸿洋大哥转发的一片知乎上的文章 原文链接 我挑了一些我喜欢的我懂了的放在这里mark下 正文 View中的isShown()方法，以前都是用view.getVisibility() == View.VISIBLE来判断的(╯□╰)； Arrays类中的asList(T… array)方法，数组转List集合；反过来List.toArray()； android.media.ThumbnailUtils类，用来获取媒体（图片、视频）缩略图； TextUtils类中的isEmpty(String)方法，判断字符串是否为null或””；（原来有自带的啊。。） TextView类中的append(String)方法，添加文本；（这个效率高，也是最近才接触的(/ □ )） View类中的getDrawingCache()等一系列方法，目前只知道可以用来截图； TextWatcher接口，用来监听文本输入框内容的改变； TextView.setError() 在验证用户输入的时候很棒。（亲测可用，后面有个红色的圆圈，白色的叹号的图片，也可自定义error图片） Build.VERSION_CODES 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到 ValueAnimator.reverse() 这个方法可以很顺利地取消正在运行的动画。 Linkify.addLinks()) 在Text上添加链接。很实用。 SystemClock.sleep()) 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。 UrlQuerySanitizer 使用这个工具可以方便对 URL 进行检查。 Tint简单说：着色，通常配合background进行使用用处：一个黑色的背景线条，我们现在想再来个绿色的，那么就不用重新加入一个资源文件，直接对黑色线条进行着色就好了 Looper、Handler、Message依旧是鸿洋大哥的博客的文章说了这一堆，那么和Handler 、 Looper 、Message有啥关系？其实Looper负责的就是创建一个MessageQueue，然后进入一个无限循环体不断从该MessageQueue中读取消息，而消息的创建者就是一个或多个Handler 。 LooperLooper主要是prepare()和loop()两个方法。其中prepare()只能搞一次，不然就。。。 public static final void prepare() { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(true)); } Looper主要作用： 与当前线程绑定，保证一个线程只会有一个Looper实例，同时一个Looper实例也只有一个MessageQueue。 loop()方法，不断从MessageQueue中去取消息，交给消息的target属性的dispatchMessage去处理。 异步消息处理线程已经有了消息队列（MessageQueue），也有了在无限循环体中取出消息的哥们，现在缺的就是发送消息的对象了，于是乎：Handler登场了。 Handler其如何与MessageQueue联系上的，它在子线程中发送的消息（一般发送消息都在非UI线程）怎么发送到MessageQueue中的。具体的去看链接哈，我这里只是一些main 首先Looper.prepare()在本线程中保存一个Looper实例，然后该实例中保存一个MessageQueue对象；因为Looper.prepare()在一个线程中只能调用一次，所以MessageQueue在一个线程中只会存在一个。 Looper.loop()会让当前线程进入一个无限循环，不断从MessageQueue的实例中读取消息，然后回调msg.target.dispatchMessage(msg)方法。 Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。 Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。 在构造Handler实例时，我们会重写handleMessage方法，也就是msg.target.dispatchMessage(msg)最终调用的方法。","raw":null,"content":null,"categories":[{"name":"android","slug":"android","permalink":"http://flowerfat.com/categories/android/"}],"tags":[]},{"title":"属性动画 -- ObjectAnimator","slug":"动画ObjectAnimation","date":"2015-08-14T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/15/动画ObjectAnimation/","link":"","permalink":"http://flowerfat.com/2015/08/15/动画ObjectAnimation/","excerpt":"前言以前在自定义View中，使用Canvas也仅仅是静态的画东西。今天来个小进阶，如题。看下效果， 来自http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0509/2851.html 简述点击查看ObjectAnimation的源码不难发现，它是继承ValueAnimator的（ValueAnimator 继承 Animator），他们都是属性动画的一份子。这次我们初探ObjectAnimation，完成一个自动画圆的过程 简单来说有这么几个步骤： 初始化画笔 初始化动画 开始动画","keywords":null,"text":"前言以前在自定义View中，使用Canvas也仅仅是静态的画东西。今天来个小进阶，如题。看下效果， 来自http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0509/2851.html 简述点击查看ObjectAnimation的源码不难发现，它是继承ValueAnimator的（ValueAnimator 继承 Animator），他们都是属性动画的一份子。这次我们初探ObjectAnimation，完成一个自动画圆的过程 简单来说有这么几个步骤： 初始化画笔 初始化动画 开始动画 /** * 初始化 paint */ private void setupProgressPaint() { progressPaint = new Paint(); progressPaint.setAntiAlias(true); // 消除锯齿 progressPaint.setStyle(Paint.Style.STROKE); // 圆环 progressPaint.setColor(Color.WHITE); // 颜色 progressPaint.setStrokeWidth(PROGRESS_STROKE_SIZE); // 圆环宽度 } /** * 初始化 动画 * 动画结束后， to do something . */ private void setupSimulateProgressAnimator() { simulateProgressAnimator = ObjectAnimator.ofFloat(this, &quot;currentProgress&quot;, 0, 100).setDuration(2000); simulateProgressAnimator.setInterpolator(new AccelerateInterpolator()); simulateProgressAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { Util.i(&quot;我是Anim&quot;, &quot;动画结束&quot;); } }); } 重点是这句，我们来看下里面的参数 ObjectAnimator.ofFloat(this, &quot;currentProgress&quot;, 0, 100).setDuration(2000); setDuration(time) 不用多说，整个动画持续的时间 0和100 分别是变量的参数值，就是说我们的圆环百分比进度currentProgress由0变到100 有一点要注意的，该java中必须有这么一个set，set后面是变量名，来自这篇博客： public void setCurrentProgress(float currentProgress) { this.currentProgress = currentProgress; postInvalidate(); } /** * 开始动画 * / public void start(){ simulateProgressAnimator.start(); } 代码package com.flowerfat.view; import android.animation.Animator; import android.animation.AnimatorListenerAdapter; import android.animation.ObjectAnimator; import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.graphics.RectF; import android.util.AttributeSet; import android.view.View; import android.view.animation.AccelerateInterpolator; import com.flowerfat.utils.Util; /** * Created by 明明大美女 on 2015/8/15. */ public class MyObjectAnimator extends View { private static final int PROGRESS_STROKE_SIZE = 10; private Paint progressPaint; private RectF progressBounds; private ObjectAnimator simulateProgressAnimator; private float currentProgress = 0; public MyObjectAnimator(Context context) { super(context); init(); } public MyObjectAnimator(Context context, AttributeSet attrs) { super(context, attrs); init(); } public MyObjectAnimator(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } private void init(){ setupProgressPaint(); setupSimulateProgressAnimator(); } /** * 初始化 paint */ private void setupProgressPaint() { progressPaint = new Paint(); progressPaint.setAntiAlias(true); progressPaint.setStyle(Paint.Style.STROKE); progressPaint.setColor(Color.WHITE); progressPaint.setStrokeWidth(PROGRESS_STROKE_SIZE); } /** * 初始化 动画 * 动画结束后， to do something . */ private void setupSimulateProgressAnimator() { simulateProgressAnimator = ObjectAnimator.ofFloat(this, &quot;currentProgress&quot;, 0, 100).setDuration(2000); simulateProgressAnimator.setInterpolator(new AccelerateInterpolator()); simulateProgressAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { Util.i(&quot;我是Anim&quot;, &quot;动画结束&quot;); } }); } /** * 这个不能少，最基本的画图 */ @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); drawArcForCurrentProgress(canvas); } @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); updateProgressBounds(); } private void updateProgressBounds() { progressBounds = new RectF( PROGRESS_STROKE_SIZE, PROGRESS_STROKE_SIZE, getWidth() - PROGRESS_STROKE_SIZE, getWidth() - PROGRESS_STROKE_SIZE ); } private void drawArcForCurrentProgress(Canvas canvas) { canvas.drawArc(progressBounds, -90f, 360 * currentProgress / 100, false, progressPaint); } public void setCurrentProgress(float currentProgress) { this.currentProgress = currentProgress; postInvalidate(); } public void start(){ simulateProgressAnimator.start(); } }","raw":null,"content":null,"categories":[{"name":"动画","slug":"动画","permalink":"http://flowerfat.com/categories/动画/"}],"tags":[{"name":"android","slug":"android","permalink":"http://flowerfat.com/tags/android/"}]},{"title":"天气预报（三）","slug":"天气预报-0813","date":"2015-08-12T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/13/天气预报-0813/","link":"","permalink":"http://flowerfat.com/2015/08/13/天气预报-0813/","excerpt":"","keywords":null,"text":"前言昨天说到车联网api， 今天执着的我又把气象数据开放平台给拿下了！ 注册，审核这个平台应该算是官网了吧。注册号就不说了，三方登陆也可以。 居然有个审核，感觉审核也挺水的 ，我尤其是什么服务器ip那个，我随便写了个192.168.1.1也通过审核了。 关于api说实话这两天都在玩天气，已经要吐了。所以这个平台的api也没试。重点在下一点 这个是重点，重点，重点气象平台的天气获取需要城市对应的id 。前面我们说到的方法都没有使用到。言归正传。 在气象数据开放平台有 区域id的下载但是！但是！ 是excel格式的，这你让我怎么用？我爱的是json啊。我的心里只有J没有E。 网上也找了有木有现成的可以直接转？失败了。找别人的json文件？没有适合我的这种层级省市县的json。 算了自己来吧，既然我是安卓开发的，就用手机来做这件事： 使用jxl这个三方库来读取excel格式的文件。 使用方法1.读取电子表格.xls文件（目录自己定哈） InputStream is = new FileInputStream(&quot;storage/sdcard0/tencent/QQfile_recv/areaid3.xls&quot;); Workbook book = Workbook.getWorkbook(is); 2.获取你需要的sheet（电子表格最下面都有sheet1，sheet2的嘛） // 获得第一个工作表对象 Sheet sheet = book.getSheet(0); 3.得到sheet以后 你就可以根据行列来获取每个block里的值了 int Rows = sheet.getRows(); // 获取该sheet的行数 int Cols = sheet.getColumns(); // 获取该sheet的列数 sheet.getCell(column, row).getContents(); // 获取第row行第column列的内容 黑好用黑简单啊有木有，这个库简直棒！ 不过几个坑需要注意了： 能读取.xls格式的，不能读取.xlsx格式的，反正我发现是这样的（电脑上用excel转换完了再用吧） 第一次读出来是乱码，中文的编解码问题，解决方法也简单，后文贴代码 jxl.jar一定要下载最新的！！！ 编码问题： WorkbookSettings workbookSettings = new WorkbookSettings(); workbookSettings.setEncoding(&quot;GBK&quot;); // 解决中文乱码，或GBK InputStream is = new FileInputStream( &quot;storage/sdcard0/tencent/QQfile_recv/areaid3.xls&quot;); Workbook book = Workbook.getWorkbook(is, workbookSettings); 如果还是编解码有问题，你可以试着在你的电脑端操作excel，另存为的时候，有个web选项（有可能在保存按钮的左边的工具里），打开web选项有个“编码”，选择Unicode试试 如何把excel里的数据转成json这个主要是逻辑问题了，大家自己来哈。可能涉及到的东西也就 jxl库的使用 Bean文件的使用 String与Json的转换（我用的是Gson 很喜欢这个jar） 保存json到本地 资源下载我转好的资源， 点击去下载 链接天气预报（四） http://www.flowerfat.com/2015/08/22/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A54-0822/天气预报（三） http://www.flowerfat.com/2015/08/13/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0813/天气预报（二） http://www.flowerfat.com/2015/08/12/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0812/天气预报（一） http://www.flowerfat.com/2015/08/11/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0811/","raw":null,"content":null,"categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://flowerfat.com/tags/android/"},{"name":"project","slug":"project","permalink":"http://flowerfat.com/tags/project/"}]},{"title":"天气预报（二）","slug":"天气预报-0812","date":"2015-08-11T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/12/天气预报-0812/","link":"","permalink":"http://flowerfat.com/2015/08/12/天气预报-0812/","excerpt":"","keywords":null,"text":"前言上次使用的360api查询天气，web调用很好，手机调用时返回的参数有的是null啊！！！ 我用的是Volley 。朋友说是服务器分段返回数据，不明觉厉，要自己写一个connection？ 车联网api上次提到的这个没有去尝试，总结如下 百度的appkey获取上次说到AS的SHA1不知道怎么获取，回去百度了下，使用java自带的keytool可以的。两种方法 一个是使用cmd，一个是使用AS的Terminal 在命令行进入到debug.keystore的目录下 妈的这里太简单了，不想写了。 遇到的坑车联网api的接口说明， 网址是这个 按照里面的接口调用get后，返回居然报错了！state：102 ， message：mcode不存在，这个参数是必须的。我擦，你api里也没这参数啊，这是啥？继续问度娘多亏了这篇文章 里面有个红色的是重点太不只能了这个api ， SHA1;package再带上去，完整的api应该是这样的： &quot;http://api.map.baidu.com/telematics/v3/weather?location=&quot;+地址+&quot;&amp;output=json&amp;ak=你的appkey&amp;mcode=你的SHA1;package&quot; 地址：java.net.URLEncoder.encode(name) 这里需要编码一下，仅仅是String是不行的 你的appkey： 这个是 获取密钥后 百度给你的 你的SHA1;package ： 这个是你获取密钥时要填的那个 有了上述的三个参数就可以使用这个api了！ 三个！不是两个！ 话又说回来其实这个api的返回结果也是比较简单的，不详细，但是带图片。而且貌似有限制 5000次 想要增加次数要发邮件给某某某，具体收费不就不晓得了。 链接天气预报（四） http://www.flowerfat.com/2015/08/22/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A54-0822/天气预报（三） http://www.flowerfat.com/2015/08/13/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0813/天气预报（二） http://www.flowerfat.com/2015/08/12/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0812/天气预报（一） http://www.flowerfat.com/2015/08/11/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0811/","raw":null,"content":null,"categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://flowerfat.com/tags/android/"},{"name":"project","slug":"project","permalink":"http://flowerfat.com/tags/project/"}]},{"title":"天气预报（一）","slug":"天气预报-0811","date":"2015-08-10T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/11/天气预报-0811/","link":"","permalink":"http://flowerfat.com/2015/08/11/天气预报-0811/","excerpt":"","keywords":null,"text":"前言最近想给工程添加个天气预报的小功能， 琢磨去晚上找个api吧， 你是不知道有多难，谁找谁知道！不是限制型收费的，就是过期不更新的，要么就是只能查一天的天气。对于我们这种屌丝来说怎么混？那么就把我的成果分享下吧 方法分类聚合数据这个还是蛮靠谱的，集成它的SDK的话，每天可以访问10000次，1万！ 不过我这人有“洁癖”，难道就没有直接调用get获得的吗？聚合这个百度吧，还是很简单的 车联网API （百度）不得不说这个看起来还挺靠谱的， 使用方法跟百度地图的有点像，需要开发者帐号，然后根据自己的SHA1和包名换一个AK，就能用了。不过这个我只是觉得靠谱，具体没用。为啥呢？唉。。。 第一次用Android Studio 不知道SHA1怎么找，，，，，，，， 360API直接百度360API居然没有，这个的发现是来自 一篇文章不知道能用到什么时候，反正现在可以，而且有一天的详情，七天的预报，还有PM2.5. 感觉正适合我啊！入了。 具体使用 获取天气获取天气很简单 就是使用http的get方法，在后面加上一个地名 http://api.lib360.net/open/weather.json?city=苏州 就是这么简单。我们来看获取到的数据：（markdown我不晓得怎么很好的展示Json格式数据，就截图了哈） 我的本地Bean文件是这么来的： /** * Created by 明明大美女 on 2015/8/11. * * 通过360api获得的天气信息 结构如下： * data[] 0~6 七天的天气信息 * data24[] 今天的天气 0~7 每三个小时的天气信息 * datanow 从data24中提出来的当前对应的天气（数据是一样的） * pm25 * * 注意！ 不同的数组[] 有些字段不同 具体在下面的注解中体现 */ public class WeatherInfo { private String AreaID; private String Year; private String Month; private String Day; private String Weather; private String WeatherICON; private String TempMax; private String TempMin; private String Wind; private String Date; private String BeginHour; private String EndHour; // data中使用的 private String WindA; private String WindB; // data24 中使用的 private String WindD; public String getAreaID() { return AreaID; } public void setAreaID(String areaID) { AreaID = areaID; } ... 篇幅有限，省略了setter和getter哈 自行添加 ... public String getWindD() { return WindD; } public void setWindD(String windD) { WindD = windD; } } 大家对比下截图 就能知道具体每个字段的含义了，很容易理解。 我曾经跟中国天气网的对比了下，信息都是一样的，虽然我的抽样只有一个样本，，， 但是！用人不疑！ 城市列表天气是获取到了，但是你城市怎么来的呢？让用户自己用EditText输入？这不失为一个办法，不过往往我们还要通过层级关系，从省到市再到区。我尼玛这又是一个坑啊。到哪儿搞一个信息完整可靠还能满足我们要求的呢？北京的朝阳区，你“=朝阳区”是获取不到天气的，要“=朝阳”，而有的又是必须带上区字才能搜索到。当然一个.Json的文件最好了。 上面是吐槽，大家自行忽略。这里来个华丽的分割线 不知道大家对爬数据有概念没？我倒是没这样，我找到一个网站叫做。心知天气。 从他的库里拎出来了数据（全球的有木有），然后他有一些我不需要的比如id啊啥的，我就给人工pass掉了。 闲话不多说，数据我打包上传到百度网盘了，链接是这个 未完待续to be continued … 相关链接天气预报（四） http://www.flowerfat.com/2015/08/22/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A54-0822/天气预报（三） http://www.flowerfat.com/2015/08/13/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0813/天气预报（二） http://www.flowerfat.com/2015/08/12/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0812/天气预报（一） http://www.flowerfat.com/2015/08/11/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5-0811/","raw":null,"content":null,"categories":[{"name":"安卓","slug":"安卓","permalink":"http://flowerfat.com/categories/安卓/"}],"tags":[{"name":"天气预报","slug":"天气预报","permalink":"http://flowerfat.com/tags/天气预报/"}]},{"title":"UI线程之子 AsyncTask","slug":"AsyncTask-0811","date":"2015-08-10T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/11/AsyncTask-0811/","link":"","permalink":"http://flowerfat.com/2015/08/11/AsyncTask-0811/","excerpt":"","keywords":null,"text":"前言为创建异步任务提供了便利， 通常用Handler向UI线程发送通知更新UI的方法代码过于臃肿，所以使用了AsyncTask来合并之前的操作。虽然有了Volley之后很少涉及到这部分了，但是还是在这里mark一下用法。 使用准备private class MyTask extends AsyncTask&lt;String, Integer, String&gt; { //onPreExecute方法用于在执行后台任务前做一些UI操作 @Override protected void onPreExecute() { Log.i(TAG, &quot;onPreExecute() called&quot;); getProvinces(); } //doInBackground方法内部执行后台任务,不可在此方法内修改UI @Override protected String doInBackground(String... params) { Log.i(TAG, &quot;doInBackground(Params... params) called&quot;); return null; } //onProgressUpdate方法用于更新进度信息 @Override protected void onProgressUpdate(Integer... progresses) { Log.i(TAG, &quot;onProgressUpdate(Progress... progresses) called&quot;); } //onPostExecute方法用于在执行完后台任务后更新UI,显示结果 @Override protected void onPostExecute(String result) { Log.i(TAG, &quot;onPostExecute(Result result) called&quot;); } //onCancelled方法用于在取消执行中的任务时更改UI @Override protected void onCancelled() { Log.i(TAG, &quot;onCancelled() called&quot;); } } 使用MyTask myTask = new MyTask(); myTask.execute(); 超链接详细说明 看这篇文章哈 有时间了我研究下再来整理 注意事项最近（20151016）看到一篇文章，阐述了AsyncTask的不足，原文点击这里，文章说Loader要更好些。 小白我不懂啊， 因为在学nodejs，嘿嘿，所以这部分以后再补充，有兴趣的朋友可以自行去百度哈","raw":null,"content":null,"categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://flowerfat.com/tags/工具/"}]},{"title":"签到0810","slug":"日记0810","date":"2015-08-09T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/10/日记0810/","link":"","permalink":"http://flowerfat.com/2015/08/10/日记0810/","excerpt":"","keywords":null,"text":"如何改变toolbar文字的颜色这里就设计到style了。盗用一张图片 一般我们要用Meterial Design风格的时候，整个应用的主题都会使用它的风格，比如： &lt;style name=&quot;Theme.DesignDemo&quot; parent=&quot;Base.Theme.DesignDemo&quot;&gt; &lt;/style&gt; &lt;style name=&quot;Base.Theme.DesignDemo&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;#02002e&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;#000000&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;#FF4081&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@color/window_background&lt;/item&gt; &lt;/style&gt; - &lt;application android:name=&quot;.MyApplication&quot; android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/Theme.DesignDemo&quot; &gt; 。。。。。 但是我发现我使用的toolbar的文字颜色不对呀，怎么是黑色的呢？于是百度了下toolbar文字的颜色，网友是这么说的：在style里加入这个： &lt;item name=&quot;android:textColorPrimary&quot;&gt;#fff&lt;/item&gt; 结果程序一加载就crash了。本人小白也不晓得什么原因，说我的导航栏出错了。 谁知道的话能告诉我下不？ 索性不加载application里了，直接放到toolbar里！ &lt;style name=&quot;ThemeToolbar&quot;&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;#fff&lt;/item&gt; &lt;/style&gt; - &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/main_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; android:theme=&quot;@style/ThemeToolbar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; 大功告成！","raw":null,"content":null,"categories":[],"tags":[{"name":"日记","slug":"日记","permalink":"http://flowerfat.com/tags/日记/"}]},{"title":"七牛云存储","slug":"七牛","date":"2015-08-07T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/08/七牛/","link":"","permalink":"http://flowerfat.com/2015/08/08/七牛/","excerpt":"","keywords":null,"text":"使用方法uploadManager.put(data, key, token, resultCallback, progressCallback); data:需要上传的内容（图片、视频的 路径） key：”development/“ + key + “_” + index 凭证（开发环境+用户id） token:从服务器获取的token resultCallback:上传结果的回调 progressCallback: 上传的进度回调","raw":null,"content":null,"categories":[],"tags":[{"name":"get","slug":"get","permalink":"http://flowerfat.com/tags/get/"}]},{"title":"Android M(Design)","slug":"Android M-0808","date":"2015-08-07T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/08/Android M-0808/","link":"","permalink":"http://flowerfat.com/2015/08/08/Android M-0808/","excerpt":"这篇文章也是东拼西凑的，看别人的理解整理的：感谢1 感谢2 功能特性视频连接(感觉没啥用) http://www.jikexueyuan.com/course/1247_1.html?ss=1 App Permissions 以前在处理权限问题上，碰到要提问权限的手机，经常很头疼。看到第一点很激动有木有，后来发现原来是5.0手机才有的方法。伤不起啊！ App Links 想办法通过链接弹到我们的应用 其他的没玩过。 Android Design一步两步，似爪牙~ CoordinatorLayout AppBarLayout CollapsingToolbarLayout Toolbar NestedScrollView FloatingActionButton 即 FAB 看这段代码： &lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/main_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/detail_backdrop_height&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/collapsing_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; android:fitsSystemWindows=&quot;true&quot; app:contentScrim=&quot;?attr/colorPrimary&quot; app:expandedTitleMarginStart=&quot;48dp&quot; app:expandedTitleMarginEnd=&quot;64dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/backdrop&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:fitsSystemWindows=&quot;true&quot; app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; app:layout_collapseMode=&quot;pin&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:paddingTop=&quot;24dp&quot;&gt; &lt;!-- 这里是你主要功能的布局，我就给略去了 --&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; app:layout_anchor=&quot;@id/appbar&quot; app:layout_anchorGravity=&quot;bottom|right|end&quot; app:rippleColor=&quot;#FFA5BE&quot; android:src=&quot;@mipmap/ic_discuss&quot; android:layout_margin=&quot;@dimen/fab_margin&quot; android:clickable=&quot;true&quot;/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;","keywords":null,"text":"这篇文章也是东拼西凑的，看别人的理解整理的：感谢1 感谢2 功能特性视频连接(感觉没啥用) http://www.jikexueyuan.com/course/1247_1.html?ss=1 App Permissions 以前在处理权限问题上，碰到要提问权限的手机，经常很头疼。看到第一点很激动有木有，后来发现原来是5.0手机才有的方法。伤不起啊！ App Links 想办法通过链接弹到我们的应用 其他的没玩过。 Android Design一步两步，似爪牙~ CoordinatorLayout AppBarLayout CollapsingToolbarLayout Toolbar NestedScrollView FloatingActionButton 即 FAB 看这段代码： &lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/main_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/detail_backdrop_height&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/collapsing_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; android:fitsSystemWindows=&quot;true&quot; app:contentScrim=&quot;?attr/colorPrimary&quot; app:expandedTitleMarginStart=&quot;48dp&quot; app:expandedTitleMarginEnd=&quot;64dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/backdrop&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:fitsSystemWindows=&quot;true&quot; app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; app:layout_collapseMode=&quot;pin&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:paddingTop=&quot;24dp&quot;&gt; &lt;!-- 这里是你主要功能的布局，我就给略去了 --&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; app:layout_anchor=&quot;@id/appbar&quot; app:layout_anchorGravity=&quot;bottom|right|end&quot; app:rippleColor=&quot;#FFA5BE&quot; android:src=&quot;@mipmap/ic_discuss&quot; android:layout_margin=&quot;@dimen/fab_margin&quot; android:clickable=&quot;true&quot;/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; CoordinatorLayout增强型的 FrameLayout: 作用：网友是这么说的：“可作为根布局；为子视图之间相互协调手势效果的一个协调布局”其实就是作为一个桥梁，便于子视图构建“相互依赖”的关系 AppBarLayoutAppBarLayout跟它的名字一样，把容器类的组件全部作为AppBar我们代码中，实际上只包含了 ImageView 和 Toolbar，就是说，把他俩整个当成一个AppBar &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/detail_backdrop_height&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/collapsing_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; android:fitsSystemWindows=&quot;true&quot; app:contentScrim=&quot;?attr/colorPrimary&quot; app:expandedTitleMarginStart=&quot;48dp&quot; app:expandedTitleMarginEnd=&quot;64dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/backdrop&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:fitsSystemWindows=&quot;true&quot; app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; app:layout_collapseMode=&quot;pin&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; CollapsingToolbarLayoutCollapsingToolbarLayout提供了一个可以折叠的Toolbar，这也是Google+、photos中的效果。Google把它做成了一个标准控件，更加方便大家使用。简言之，有了它，AppBarLayout里的ImageView采可以实现缩放的那种效果 这里有一个属性 app:layout_scrollFlags=”scroll|exitUntilCollapsed” 这个是和 NestedScrollView中的 app:layout_behavior=”@string/appbar_scrolling_view_behavior” 配套使用的。啥意思？这时候CoordinatorLayout的作用就来了，CoordinatorLayout可以说是这次support library更新的重中之重。它从另一层面去控制子view之间触摸事件的布局，Design library中的很多控件都利用了它。在我们的代码中，NestedScrollView是可上下滚动的，而CollapsingToolbarLayout是要通过其滚动而变化的，那么： 1 给这个可滚动组件设置了layout_behavior：android.support.design.widget.AppBarLayout$ScrollingViewBehavior2 给另一个控件设置了layout_scrollFlags那么，当设置了layout_behavior的控件滑动时，就会触发设置了layout_scrollFlags的控件发生状态的改变。 关于layout_scrollFlags的值我这里再说一下： scroll - 想滚动就必须设置这个。enterAlways - 实现quick return效果, 当向下移动时，立即显示View（比如Toolbar)。exitUntilCollapsed - 向上滚动时收缩View，但可以固定Toolbar一直在上面。enterAlwaysCollapsed - 当你的View已经设置minHeight属性又使用此标志时，你的View只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。 而里面的app属性 app:contentScrim=”?attr/colorPrimary” 设置当完全CollapsingToolbarLayout折叠(收缩)后的背景颜色。app:expandedTitleMarginStart=”48dp” 设置扩张时候(还没有收缩时)title向左填充的距离app:expandedTitleMarginEnd=”64dp” 设置扩张时候(还没有收缩时)title向右填充的距离 Toolbar现在我们可以不用actionBar了。 至于Toolbar， 看这篇文章哈， 总结的很好。 这里还有一个小玩意儿，就是点击了左上角的图标后的动画： ActionBarDrawerToggle mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, toolbar, R.string.title_activity_activity_welcome, R.string.title_activity_activity_welcome); mDrawerToggle.syncState(); mDrawerLayout.setDrawerListener(mDrawerToggle); 虽然我们这个工程加入这个不明显（因为导航栏出来后给遮挡住了，基本看不到动画），但是也要mark一下嘛 TabLayouthttp://blog.csdn.net/tgzzl/article/details/47208799 NestedScrollView你以为这就是一个ScrollView？ NoNoNo. 它对子View和父View的触摸事件有着独到的见解。如果你理解为ScrollView ， 你可以试着把上面的代码中，替换成ScrollView 会发现居然不能滑动了！具体我还没深入研究，倒是找到一片相关的文章 FloatingActionButton嗯 没错 这其实就是一个控件 用起来也颇为简单，直接拿来就能用。不过这里因为我们要配合其他View进行某些动画，所以里面还是要有几个必要的属性的 app:layout_anchor=”@id/appbar” 跟下面的搭配使用的，我理解就是抱大腿（根据id）app:layout_anchorGravity=”bottom|right|end” 我理解就是一个相对于大腿位置（right和end貌似是一个东西）app:rippleColor=”#FFA5BE” 按下后的颜色（不必要） 总结 CoordinatorLayout 给子控件添加依赖关系 AppBarLayout 它包含的整个作为一个Appbar CollapsingToolbarLayout 放在AppBarLayout中使用，缩放的效果","raw":null,"content":null,"categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://flowerfat.com/tags/控件/"}]},{"title":"混淆与反编译","slug":"混淆与反编译","date":"2015-08-06T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/07/混淆与反编译/","link":"","permalink":"http://flowerfat.com/2015/08/07/混淆与反编译/","excerpt":"","keywords":null,"text":"首先感谢 极客学院 的 ime老师 视频链接 先来列举下主要目录吧 通过 apktool 反编译（把apk变成工程文件，包括src和res等） 使用 apktool 将反编译后的文件，（可以自己改一改java，xml啥的）再重新编译成apk！！！ 不道德啊。 后面不详说。 混淆代码 我们主要看好的是 反编译后学习别人的代码、代码混淆。所以下面主要说下1和3两点 代码混淆题外话，混淆都是骗小孩的。只能说让别人反编译起来更加困难。如果能难到他不想继续下去，你就赢了。有没有想到：金蛇缠粘手！ 使用android自带的混淆在project.properties文件中加入一句 target=android-22 proguard.config=proguard-project.txt 这样就“隐藏”了所有的类，如果某个类保留（不混淆某个类）那么就要在proguard-project.txt文件中如下操作 -keep class yourclass path+name -keep class com.flowerfat.helloWorld.classname 这我就有疑问了：studio中应该怎么混淆？混淆就混淆呗，为啥要保留某些类？ 深层次混淆我们在开发过程中，有一些核心的算法，重要的部分不希望别人看到，比如支付部分。那么我们要怎样做呢？ NDK 让C++飞起来 反编译文章链接 内容真是多，最近有点暴躁就先不看了 以后再来总结。 实在不行就用360加固保","raw":null,"content":null,"categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://flowerfat.com/categories/knowledge/"}],"tags":[{"name":"android","slug":"android","permalink":"http://flowerfat.com/tags/android/"}]},{"title":"彩云之癫","slug":"云南","date":"2015-08-05T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/06/云南/","link":"","permalink":"http://flowerfat.com/2015/08/06/云南/","excerpt":"","keywords":null,"text":"我们去云南旅游吧，我带着你，你带着钱，你特么。。。","raw":null,"content":null,"categories":[],"tags":[{"name":"dear","slug":"dear","permalink":"http://flowerfat.com/tags/dear/"}]},{"title":"Fresco 与 RecyclerView","slug":"学习笔记","date":"2015-08-05T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/06/学习笔记/","link":"","permalink":"http://flowerfat.com/2015/08/06/学习笔记/","excerpt":"Fresco图片属性提供了各种图 不存在scaleType 而是换成了自己的，具体如下：摘取自这里 正常图：actualImageScaleType=”focusCrop” //设置图片缩放. 通常使用focusCrop,该属性值会通过算法把人头像放在中间 占位图：placeholderImage —&gt;&gt; placeholderImageScaleType 加载图：progressBarImage —&gt;&gt; progressBarImageScaleType 失败图：failureImage —&gt;&gt; failureImageScaleType 重载图：retryImage —&gt;&gt; retryImageScaleType 其他修改图片尺寸 Uri uri = &quot;file:///mnt/sdcard/MyApp/myfile.jpg&quot;; int width = 50, height = 50; ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri) .setResizeOptions(new ResizeOptions(width, height)) .build(); PipelineDraweeController controller = Fresco.newDraweeControllerBuilder() .setOldController(mDraweeView.getController()) .setImageRequest(request) .build(); mSimpleDraweeView.setController(controller); 自动旋转 ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri) .setAutoRotateEnabled(true) .build();","keywords":null,"text":"Fresco图片属性提供了各种图 不存在scaleType 而是换成了自己的，具体如下：摘取自这里 正常图：actualImageScaleType=”focusCrop” //设置图片缩放. 通常使用focusCrop,该属性值会通过算法把人头像放在中间 占位图：placeholderImage —&gt;&gt; placeholderImageScaleType 加载图：progressBarImage —&gt;&gt; progressBarImageScaleType 失败图：failureImage —&gt;&gt; failureImageScaleType 重载图：retryImage —&gt;&gt; retryImageScaleType 其他修改图片尺寸 Uri uri = &quot;file:///mnt/sdcard/MyApp/myfile.jpg&quot;; int width = 50, height = 50; ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri) .setResizeOptions(new ResizeOptions(width, height)) .build(); PipelineDraweeController controller = Fresco.newDraweeControllerBuilder() .setOldController(mDraweeView.getController()) .setImageRequest(request) .build(); mSimpleDraweeView.setController(controller); 自动旋转 ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri) .setAutoRotateEnabled(true) .build(); 又是一个坑RecycleView在使用RecyclerView的时候, 错误提示： java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child&apos;s parent first. 不明觉厉，什么鬼？又特么百度不到。可以验证，不是布局的问题。辣么来看java中的code： public void recyclerViewInit() { mRecyclerView.setHasFixedSize(true); // use a linear layout manager LinearLayoutManager manager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(manager); // specify an adapter (see also next example) mAdapter = new TestAdapter(strs); mRecyclerView.setAdapter(mAdapter); } 打过log后发现 多半是自己的Adapter太搓。 果然换了个别人的Adapter就好了。我了个*。疯狂对比两者的不同，发现背锅的在这里： 。。。嗯 这里先卖个关子，让我们先来看看超级ListView的的Adapter该怎么搞，就以跟ListView的不同来重点描述吧 public class className extends RecyclerView.Adapter&lt;className.ViewHolder&gt; 这里继承的不再是BaseAdapter了。有人会问了，classNmae后面的.ViewHolder是啥子？我们需要在这个adapter类里定义一个 public static class ViewHolder extends RecyclerView.ViewHolder { // each data item is just a string in this case public TextView mTextView; public ViewHolder(View v) { super(v); mTextView = (TextView)v.findViewById(R.id.adapter_test_tv); } } 没错，这个和以前的ViewHolder类似. 必须要重写的东西也变了，我们来分别说下这三个是干啥的：– 没啥说的 返回条目数 public int getItemCount() { return mDatas.size(); } – 将数据显示 public void onBindViewHolder(final ViewHolder holder, int position) { holder.mTextView.setText(mDatas.get(position)); } – 获取布局，并定义ViewHolder，将布局传递给ViewHolder public TestAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { // create a new view View v = LayoutInflater.from(parent.getContext()) .inflate(R.layout.adapter_recycle, parent, false); ViewHolder vh = new ViewHolder(v); return vh; } 来个完整版的adapter public class TestAdapter extends RecyclerView.Adapter&lt;TestAdapter.ViewHolder&gt; { private String[] mDatas; // Provide a reference to the views for each data item // Complex data items may need more than one view per item, and // you provide access to all the views for a data item in a view holder public static class ViewHolder extends RecyclerView.ViewHolder { // each data item is just a string in this case public TextView mTextView; public ViewHolder(View v) { super(v); mTextView = (TextView)v.findViewById(R.id.adapter_test_tv); } } // Provide a suitable constructor (depends on the kind of dataset) public TestAdapter(String[] myDataset) { mDatas = myDataset; } @Override public TestAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { // create a new view View v = LayoutInflater.from(parent.getContext()) .inflate(R.layout.adapter_recycle, parent, false); ViewHolder vh = new ViewHolder(v); return vh; } @Override public void onBindViewHolder(TestAdapter.ViewHolder holder, int position) { holder.mTextView.setText(mDatas[position]); } @Override public int getItemCount() { return mDatas.length; } } 细细品味下来，会发现其实特么跟以前差不多嘛，只是结构换了。但为啥大家都说比ListView好呢？我们下回分解-.- 哦，对了 背锅的在这里 错误的地方： 这个是我从一本书里copy过来的，注意第一个函数的ViewHolder(TextView v) public static class ViewHolder extends RecyclerView.ViewHolder { // each data item is just a string in this case public TextView mTextView; public ViewHolder(TextView v) { super(v); mTextView = v; } } // Create new views (invoked by the layout manager) @Override public MyAdapter.ViewHolder onCreateViewHolder(ViewGroup parent,int viewType) { // create a new view View v = LayoutInflater.from(parent.getContext()) .inflate(R.layout.my_text_view, parent, false); // set the view&apos;s size, margins, paddings and layout parameters ... ViewHolder vh = new ViewHolder(v); return vh; }","raw":null,"content":null,"categories":[],"tags":[{"name":"get","slug":"get","permalink":"http://flowerfat.com/tags/get/"},{"name":"android","slug":"android","permalink":"http://flowerfat.com/tags/android/"}]},{"title":"Tips 0805","slug":"2015-08-05","date":"2015-08-04T16:00:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/05/2015-08-05/","link":"","permalink":"http://flowerfat.com/2015/08/05/2015-08-05/","excerpt":"","keywords":null,"text":"Welcome to 胖小了个花! This is my homePage. 学习分享Tips1权衡之下，决定不使用Annotation了，有它的优势，不过不能使用BaseActivity了。 Tips2今天对 Meterial Design 进行了熟悉。 抽屉NavigationView的优势在于代码简单，可扩展性比之前的三方要差，不过可以用ListView进行自定义1.5 关于抽屉的点击事件，menu的是setNavigationItemSelectedListener，但header的点击是啥？网上找不到有木有！我尼玛屌丝啊，你丫直接findViewById(R.id.nav_header_parent).setOnClickListener啊，汗~ FAB 悬浮的一个button，就是一个简单控件，不用多说，扩展可以看这篇文章 CoordinatorLayout 高端，具体还没有理解透，后续补充吧 （AppBarLayout、CollapsingToolbarLayout、Toolbar） 小小坑1. FAB compile ‘com.android.support:design:22.2.0’的FAB是方形的，升级成22.2.1就是圆形的了。。。 2. Snackbar 这个snackbar怎么改变颜色？对于按钮Action的text默认是style中name=”colorAccent”的颜色，可自行设置。可正文怎么变颜色？ google说Snackbar是较轻量级的（比Dialog），但有网友测试，连续点击，gc不会及时回收，对于内存吃紧的情况，慎用。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"hexo心得","slug":"hexo使用心得","date":"2015-08-04T05:08:00.000Z","updated":"2015-11-09T19:54:10.000Z","comments":true,"path":"2015/08/04/hexo使用心得/","link":"","permalink":"http://flowerfat.com/2015/08/04/hexo使用心得/","excerpt":"","keywords":null,"text":"Welcome to 胖小了个花! This is my mainIndex. mark一下，我的md编辑器用的是这个 http://pan.baidu.com/s/1sjE9HAt 解压密码是 ttrar.com 有一些东西是可以在主_config里设置的：每页显示几篇文章（per_page: 3） – 终于知道！ 左侧最下端的圆形连接：source/css/_partial/main.styl 在里面参照博主的添加。 – 给文章添加图片： ![网络图片](http://i.imgur.com/pRGOdor.jpg) ![本地图片](/images/123.jpg) 注意在根目录的source文件夹下建立一个images文件夹，在里面放图片 tags的使用：一个-&gt;tags: [name1]&lt;———&gt;两个-&gt;tags: [name1,name2] – 添加视频 &lt;iframe height=498 width=510 src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt; – 添加音频 — 其中auto=1为自动播放, auto=0反之 &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=29431066&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;","raw":null,"content":null,"categories":[],"tags":[]}]}